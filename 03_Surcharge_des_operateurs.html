<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>HE-Arc - 1242.2 Langage C++ - Chapitre 3 - Surcharge des opérateurs</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/hearc.css" id="theme">
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="https://www.he-arc.ch/wp-content/uploads/2021/12/cropped-hearc-icon-192x192.png"
    type="image/vnd.microsoft.icon" />

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/vs.css" id="highlight-theme">
</head>

<body>
  <img id="logo-hearc" src="./medias/logo_he-arc.png" alt="Logo HE-ARC">
  <img id="logo-hesso" src="./medias/logo_hes-so.png" alt="Logo HES-SO">
  <p id="course-infos">1242.2 Langage C++ - 2025-2026</p>

  <div class="reveal">
    <div class="slides">

      <!----------          TITLE          ---------->
      <section>
        <h1>
          Chapitre 3
        </h1>
        <h2>
          Surcharge des opérateurs
        </h2>
        <div class="container">
          <div class="col-left">
            <p>1. Introduction</p>
            <p>2. Surcharges des opérateurs</p>
            <p>3. Surcharge de <inline-code><<</inline-code> et <inline-code>>></inline-code></p>
          </div>
          <div class="col-right">
            <p>4. Surcharge de <inline-code>=</inline-code></p>
            <p>5. Autres surcharges (<inline-code>++</inline-code>, <inline-code>--</inline-code>, ...)</p>
            <p>6. Bonnes pratiques</p>
          </div>
        </div>
      </section>

      <!----------          INTRODUCTION          ---------->
      <section>
        <h2>3.1 Introduction</h2>
        <p><inline-code>Complex c1(2,3), c2(1,1), c3;</inline-code></p>
        <p>Comment les additionner ?</p>
        <br>
        <p><inline-code>c3 = Complex::add(c1, c2);</inline-code></p>
        <p>ou</p>
        <p><inline-code>c3 = c1.Add(c2);</inline-code></p>
        <br>
        <h3>Idéalement, on aimerait :</h3>
        <p><inline-code>c3 = c1 + c2;</inline-code></p>
      </section>

      <!----------          SURCHARGE DES OPÉRATEURS          ---------->
      <section>

        <section>
          <h2>3.2 Surcharge des opérateurs</h2>
          <p>Permet de redéfinir le comportement des opérateurs</p>
          <p>Pour manipuler les objets comme des types simples</p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            
            Complex c1(2,3), c2(1,1), c3;
            c3 = c1 + c2;
            std::cout << c1 << std::endl;
          </code></pre>
          <br>
          <p>On ne peut pas redéfinir les opérateurs sur les types primitifs</p>
          <p>Seulement pour les classes/struct définies par nous</p>
          <p>Seuls les opérateurs existants peuvent être surchargés</p>
          <br>
          <p>✅ Conserver la sémantique initiale de l'opérateur</p>
        </section>

        <section>
          <h2>3.2 Surcharge des opérateurs</h2>
          <p><success>✅ Peuvent être surchargés</success></p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">

            =	+	-	*	/	^	%
            == 	+= 	-= 	*= 	/= 	^= 	%=
            < 	<= 	> 	>= 	<< 	>> 	<<=
            >>= 	++ 	-- 	& 	| 	! 	&=
            |= 	!= 	,	 [] 	()	&& 	||	
            ~	xor	xor_eq	and	and_eq	or 	or_eq
            not	not_eq	bitand	bitor	compl
          </code></pre>
          <p><warning>⚠️ Dangeureux</warning></p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            
            -> 	->* 	new 	new[]	delete	delete[]
          </code></pre>
          <p><error>⛔ Interdit</error></p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            
            .	.*	::	?:	sizeof
          </code></pre>
        </section>

        <section>
          <h2>3.2 Surcharge des opérateurs</h2>
          <p>Pour chaque opérateur ♦, il existe une méthode <inline-code>operator♦(...)</inline-code></p>
          <br>
          <p><inline-code>c1+c2;</inline-code> est transformé en <inline-code>c1.operator+(c2);</inline-code></p>
          <p><inline-code>c1=c2;</inline-code> est transformé en <inline-code>c1.operator=(c2);</inline-code></p>
          <br>
          <p><inline-code>p1=p2=p3;</inline-code> est transformé en <inline-code>p1.operator=(p2.operator=(p3));</inline-code></p>
        </section>

        <section>
          <h2>3.2 Surcharge des opérateurs</h2>
          <h3>A) Par une fonction membre</h3>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            // Complex.h
            class Complex 
            {
              public:
                // ⚠️ this and argument are const
                Complex operator+(const Complex &) const;
              private:
                  double real;
                  double imag;
            };
          </code></pre>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            // Complex.cpp
            Complex Complex::operator+(const Complex &c) const
            {
              return Complex(r + c.r, i + c.i);
            }
          </code></pre>        
        </section>

        <section>
          <h2>3.2 Surcharge des opérateurs</h2>
          <h3>A) Par une fonction membre</h3>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            Complex c1, c2, c;
            int x, y;
            
            c = c1 + c2; // ✅ c = c1.operator+(c2);

            // ✅ if conversion exists
            c = c1 + y;  // ✅ c = c1.operator+(Complex(y));

            // ⛔ x.operator+(c2) does not compile
            c = x + c2;  // ⛔ x is not a Complex
          </code></pre>
        </section>

        <section>
          <h2>3.2 Surcharge des opérateurs</h2>
          <h3>B1) Par une fonction non-membre</h3>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            // ⚠️ Needs accessors
            Complex operator+(const Complex &x, const Complex &y)
            {
              return Complex(<error>x.getR() + y.getR(), x.getI() + y.getI()</error>);
            }
          </code></pre>
          <br>
          <h3>B2) Par une fonction non-membre <span style="text-transform: lowercase;"><inline-code>friend</inline-code></span></h3>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            // Complex.h
            friend Complex operator+(const Complex&, const Complex&);
          </code></pre>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            Complex operator+(const Complex &x, const Complex &y)
            {
              return Complex(<success>x.r + y.r, x.i + y.i</success>);
            }
          </code></pre>
        </section>

        <section>
          <h2>3.2 Surcharge des opérateurs</h2>
          <h3>B) Par une fonction non-membre</h3>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            Complex c1, c2, c;
            int x, y;
            
            c = c1 + c2; // ✅ c = operator+(c1, c2);

            // ✅ if conversion exists
            c = c1 + y;  // ✅ c = operator+(c1, Complex(y));

            // ✅ if conversion exists
            c = x + c2;  // ✅ c = operator+(Complex(x), c2);
          </code></pre>
        </section>

      </section>

      <!----------          SURCHARGE DE << ET >>          ---------->
      <section>
        <section>
          <h2>3.3 Surcharge de <inline-code><<</inline-code> et <inline-code>>></inline-code></h2>
          <p>Les opérateurs <inline-code><<</inline-code> et <inline-code>>></inline-code> permettent d'insérer et d'extraire des objets dans les flux</p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">

            ostream& operator<<(ostream &s, const Point &p)
            {
              return s << '(' << p.X() << ',' << p.Y() << ')';
            }
          </code></pre>
          <p>L'opérande de gauche est une référence sur le flux <inline-code>ostream&</inline-code></p>
          <p>Cette fonction ne pourra pas être membre de la classe <inline-code>Point</inline-code></p>
          <p>Le renvoi d'une référence permet de l'utiliser comme lvalue</p>
          <p>On pourra donc faire des appels en cascade :</p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            cout << p1 << p2 << endl; 
            operator<<(operator<<(operator<<(cout, p1), p2), endl);
                                  |-----------------| ostream&
                      |---------------------------------| ostream&
            |---------------------------------------------------| ostream&
          </code></pre>
        </section>

        <section>
          <h2>3.3 Surcharge de <inline-code><<</inline-code> et <inline-code>>></inline-code></h2>
          <p>Exemple d'utilisation d'<inline-code>operator>></inline-code></p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">

            void main() 
            {
              Point p;
              std::cout << "Donner un point au format (x,y) : ";
              std::cin >> p;
              std::cout << "Le point est : " << p << std::endl;
            }
          </code></pre>
          <p>On veut que l'utilisateur respecte un format prédéfini :</p>
          <p><inline-code>parenthèse-X-virgule-Y-parenthèse</inline-code></p>

          <pre style="width: 1600px;"><code 
            class="bash"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            
            Donner un point : ( 2 , 3 )
            Le point est : (2,3)
          </code></pre>
        </section>

        <section>
          <h2>3.3 Surcharge de <inline-code><<</inline-code> et <inline-code>>></inline-code></h2>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            istream& operator>>(istream &i, Point &p)
            {
              char c;
              i >> c;
              if (c == '(')
              {
                i >> p.x >> c;
                if (c == ',')
                {
                  i >> p.y >> c;
                  if (c == ')')
                    return i;
                }
              }
              std::cerr << "Erreur de lecture." << std::endl;
              return i;
            }
          </code></pre>
        </section>
        
      </section>

      <!----------          SURCHARGE DE =          ---------->
      <section>

        <section>
          <h2>3.4 Surcharge de <inline-code>=</inline-code></h2>
          <p>L'affectation est une opération prédéfinie</p>
          <p>Doit parfois être redéfini pour des copies en profondeur</p>
          <p>⚠️ affectation vs construction par copie</p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">

            void main()
            {
              NamedPoint pt(1, 4, "P1"), copyPt;

              // ⚠️ Constructeur par copie
              NamedPoint copyPt2 = p;
              
              // ⚠️ Affectation
              copyPt = pt;
            }
          </code></pre>
        </section>

        <section>
          <h2>3.4 Surcharge de <inline-code>=</inline-code></h2>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">

            class NamedPoint
            {
              public:
                NamedPoint(int = 0, int = 0, char* = nullptr);
                NamedPoint(const NamedPoint &);
                ~NamedPoint();

              private:
                int x, y;
                char* name;
            };           
          </code></pre>
        </section>
        
        <section>
          <h2>3.4 Surcharge de <inline-code>=</inline-code></h2>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">

            // ✅ Return reference to allow chaining
            NamedPoint& NamedPoint::operator=(const NamedPoint &p)
            {
              // ✅ Avoid self-assignment
              if (this != &p)
              {
                x = p.x;
                y = p.y;
                if(name != 0)
                  delete [] name;
                  
                name = new char[strlen(p.name)+1];
                strcpy(name, p. name);
              }
              
              return *this;
            }
          </code></pre>
        </section>

      </section>

      <!----------          AUTRES SURCHARGES          ---------->
      <section>

        <section>
          <h2>3.5 Autres surcharges</h2>
          <p>Les opérateurs de conversion</p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">

            class Point
            {
              int x, y;
              ...
              // Conversion int → Point Constructeur
              Point(int a) {x = a; y = 0;}
              
              // Conversion Point → int   Surcharge op
              operator int(){return abs(x) + abs(y);}
            };
          </code></pre>
        </section>

        <section>
          <h2>3.5 Autres surcharges</h2>
          <p>Les opérateurs d'incrémentation et de décrémentation</p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            class Point
            {
              ...
              // ⚠️ Pré-incrémentation
              Point& operator++()
              {
                x++; y++;
                return *this;
              }
              
              // ⚠️ Post-incrémentation
              Point operator++(int)
              {
                Point tmp(*this);
                x++; y++;
                return tmp;
              }
            };
          </code></pre>
        </section>
      </section>

      <!----------          THE RULE OF THREE          ---------->
      <section>

        <section>
          <h2>3.6 Bonnes pratiques</h2>
          <h3>Où surcharger les opérateurs ?</h3>
          <br>
          

        </section>

        <section>
          <h2>3.6 Bonnes pratiques</h2>
          <h3>The Rule of 3</h3>
          <br>
          <h3><center>Si une classe définit le destructeur, le constructeur par copie ou l'opérateur d'affectation, elle devrait probablement définir les 3</center></h3>
        </section>
      
      </section>


    </div>
  </div>

  <!----------          CONTENT          ---------->

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,
      width: 1920,
      height: 1080,
      transition: "none",
      center: false,
      slideNumber: 'c/t',

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>