<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>HE-Arc - 1242.2 Langage C++ - Chapitre 9 - Biblioth√®que standard</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/hearc.css" id="theme">
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="https://www.he-arc.ch/wp-content/uploads/2021/12/cropped-hearc-icon-192x192.png"
    type="image/vnd.microsoft.icon" />

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/vs.css" id="highlight-theme">
</head>

<body>
  <img id="logo-hearc" src="./medias/logo_he-arc.png" alt="Logo HE-ARC">
  <img id="logo-hesso" src="./medias/logo_hes-so.png" alt="Logo HES-SO">
  <p id="course-infos">1242.2 Langage C++ - 2024-2025</p>

  <div class="reveal">
    <div class="slides">

      <!----------          TITLE          ---------->
      <section>
        <h1>
          Chapitre 9
        </h1>
        <h2>
          Biblioth√®que standard
        </h2>
        <div class="container">
          <div class="col-left">
            <p>1. Vue d'ensemble</p>
            <p>2. Flux et fichiers</p>
            <p>3. Flux et <inline-code>
                <highlight>std::string</highlight>
              </inline-code></p>
            <p>4. Conteneurs s√©quentiels</p>
          </div>
          <div class="col-right">
            <p>5. It√©rateurs</p>
            <p>6. Conteneurs associatifs</p>
            <p>7. Smart pointers</p>
            </p>
          </div>
        </div>
      </section>

      <!----------          9.1 Vue d'ensemble          ---------->
      <section>

        <section>
          <h2>9.1 Vue d'ensemble</h2>
          <p>Ensemble de classes et de fonctions qui fournissent des fonctionnalit√©s courantes</p>
          <p>Divis√©e en plusieurs parties, chacune ayant un but sp√©cifique</p>
          <p>D√©finie dans le namespace <inline-code><highlight>std</highlight></inline-code></p>
          <p>Incluse par d√©faut dans la plupart des compilateurs C++ modernes</p>
          <p>Plus de 50 fichiers d'en-t√™te : <inline-code><highlight>iostream</highlight></inline-code>, <inline-code><highlight>vector</highlight></inline-code>, <inline-code><highlight>list</highlight></inline-code>, <inline-code><highlight>string</highlight></inline-code>, ...</p>
          <h3>En particulier</h3>
          <p>- La biblioth√®que standard C</p>
          <p>- Gestion des exceptions</p>
          <p>- Gestion des flux</p>
          <p>- Gestion des cha√Ænes de caract√®res</p>
          <p>- La biblioth√®que standard template library (STL)</p>
          <p>- Support pour le calcul num√©rique</p>
          <p>- Des codes √©prouv√©s (algorithmes, ...)</p>
        </section>

      </section>

      <!------------          9.2 Flux et fichiers          ---------->
      <section>

        <section>
          <h2>9.2 Flux et fichiers</h2>
          <p>Un flux est une s√©quence d'octets transf√©r√©s entre la m√©moire et les p√©riph√©riques</p>
          <p>C'est le programme qui donne une signification aux octets d'un flux</p>
          <p>Les flux fournissent une m√©thode unifi√©e pour traiter les E/S quels que soient les p√©riph√©riques et les
            types de donn√©es √† √©changer</p>
          <p>Classes impl√©mentant des flux :</p>
          <p>- <inline-code>
              <highlight>iostream</highlight>
            </inline-code> : flux standard d'E/S (clavier / √©cran)</p>
          <p>- <inline-code>
              <highlight>fstream</highlight>
            </inline-code> : flux d'E/S dans les fichiers</p>
          <p>- <inline-code>
              <highlight>sstream</highlight>
            </inline-code> : flux d'E/S dans la m√©moire (string)</p>
          <p>- ...</p>
          <br>
          <!-- NOTE: we use html code here because auto-formating with << breaks the code -->
          <p>Toutes ces classes red√©finissent les op√©rateurs <inline-code><highlight>&#60;&#60;</highlight></inline-code> et <inline-code><highlight>>></highlight></inline-code>
        </section>

        <section>
          <h2>9.2 Les fichiers</h2>
          <p>2 types de fichiers : texte (par d√©faut) ou binaire</p>
          <p>2 modes d'acc√®s : s√©quentiel ou direct (random access)</p>
          <p><inline-code><highlight></highlight>#include &#60;fstream&#62;</inline-code> ‚áí 3 classes :</p>
          <p>- <inline-code><highlight>ifstream</highlight></inline-code> : entr√©e (lecture)</p>
          <p>- <inline-code><highlight>ofstream</highlight></inline-code> : sortie (√©criture)</p>
          <p>- <inline-code><highlight>fstream</highlight></inline-code> : entr√©e/sortie (lecture/√©criture)</p>
          <p>L'ouverture peut se faire par l'appel du constructeur ou de la m√©thode <inline-code><highlight>open()</highlight></inline-code> ayant la m√™me signature, seules les valeurs par d√©faut changent :</p>
          <p><inline-code><highlight>ifstream::ifstream(const char* f, openmode mode = ios::in)</highlight></inline-code></p>
          <p><inline-code><highlight>ofstream::ofstream(const char* f, openmode mode = ios::out)</highlight></inline-code></p>
          <p><inline-code><highlight>fstream::fstream(const char* f, openmode mode = ios::in | ios::out)</highlight></inline-code></p>
          <p>Fermeture avec la m√©thode <inline-code><highlight>close()</highlight></inline-code> ou automatiquement par le destructeur</p>
        </section>

        <section>
          <h2>9.2 Les param√®tres d'ouverture</h2>
          <p>Le param√®tre <inline-code>f</inline-code> est le nom du fichier √† ouvrir</p>
          <p>Le param√®tre <inline-code>mode</inline-code> est un bitfield qui d√©finit le mode d'ouverture du fichier</p>
          <p>On le combine avec l'op√©rateur bit √† bit <inline-code>|</inline-code></p>
          <p><b>Exemple :</b> ouverture d'un fichier texte en √©criture par ajout (√† la fin)</p>
          <p><inline-code><highlight>fstream fs("log.txt", ios::out | ios::app)</highlight></inline-code></p>
          <br>
          <p><b>Modes</b></p>
          <p>- <inline-code><highlight>ios::binary</highlight></inline-code> : mode binaire (mode texte par d√©faut)</p>
          <p>- <inline-code><highlight>ios::in</highlight></inline-code> : lecture (d√©faut pour <inline-code><highlight>ifstream</highlight></inline-code>)</p>
          <p>- <inline-code><highlight>ios::out</highlight></inline-code> : √©criture (d√©faut pour <inline-code><highlight>ofstream</highlight></inline-code>)</p>
          <p>- <inline-code><highlight>ios::app</highlight></inline-code> : ajout √† la fin (append)</p>
          <p>- <inline-code><highlight>ios::trunc</highlight></inline-code> : √©crase le contenu pr√©c√©dent (truncate)</p>
          <p>- <inline-code><highlight>ios::ate</highlight></inline-code> : position √† la fin d√®s l'ouverture</p>
        </section>

        <section>
          <h2>9.2 Les param√®tres d'ouverture</h2>
          <p><b>2 mani√®res d'ouvrir un fichier</b></p>
          <br>
          <p>1. Par le constructeur de la classe</p>
          <p><inline-code>
              <highlight>ifstream myFile("data.bin", ios::in | ios::binary)</highlight>
            </inline-code></p>
          <p>2. Par la m√©thode <inline-code>
              <highlight>open()</highlight>
            </inline-code></p>
          <p><inline-code>
              <highlight>ifstream myFile</highlight>
            </inline-code></p>
          <p><inline-code>
              <highlight>myFile.open("data.bin", ios::in | ios::binary)</highlight>
            </inline-code></p>
          <p>Pour des fichiers en √©criture et lecture, utiliser fstream</p>
          <p><inline-code>
              <highlight>fstream myFile("data.bin", ios::in | ios::out | ios::binary)</highlight>
            </inline-code></p>
          <br>
          <p>
            <warning>‚ö†Ô∏è Attention :</warning> mode "binaire", vraiment ? voir <a href="https://stackoverflow.com/questions/14767857/unexpected-results-with-stdofstream-binary-write">(<< vs .write())</a></p>
        </section>

        <section>
          <h2>9.2 Exemple</h2>
          <pre style="width: 1800px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">

            #include &#60;iostream&#62;
            #include &#60;fstream&#62;
            
            int main()
            {
              std::ofstream fOutput("myFile.txt");
              fOutput << "PI = " << 3.14159 << '.' << std::endl;
              fOutput.close();
              
              std::ifstream fInput("myFile.txt");
              std::string s; double d; char c;
              fInput >> s >> d >> c;
              fInput.close();
              
              std::cout << s << d  << c << std::endl;
            
              return 0;
            }
          </code></pre>
        </section>

        <section>
          <h2>9.2 Exemple</h2>
          <p>
            <warning>‚ö†Ô∏è Attention</warning>
          </p>
          <p>L'utilisation des flux pour acc√©der aux fichiers soul√®ve les m√™mes probl√©matiques que pour la console</p>
          <p>En particulier, les caract√®res blancs sont consid√©r√©s comme des s√©parateurs</p>
          <p>On peut utiliser la fonction <inline-code><highlight>getline()</highlight></inline-code> pour lire une ligne enti√®re</p>
        </section>

        <section>
          <h2>9.2 Traitements d'erreurs</h2>
          <p>Traitement d'erreurs identique pour tous les flux (fichier, √©cran/clavier, m√©moire)</p>
          <p>Bas√© sur 4 bits (flags <inline-code>ios_base::iostate</inline-code>) : <inline-code>goodbit</inline-code>,
            <inline-code>badbit</inline-code>, <inline-code>failbit</inline-code> et <inline-code>eofbit</inline-code>
          </p>
          <p>On peut tester et manipuler l'√©tat du flux avec les m√©thodes suivantes :</p>
          <p>- <inline-code><highlight>good()</highlight></inline-code> : aucune erreur</p>
          <p>- <inline-code><highlight>bad()</highlight></inline-code> : impossible d'extraire des donn√©es du flux</p>
          <p>- <inline-code><highlight>fail()</highlight></inline-code> : √©chec de l'op√©ration</p>
          <p>- <inline-code><highlight>eof()</highlight></inline-code> : fin de fichier</p>
          <p>- <inline-code><highlight>clear()</highlight></inline-code> : r√©initialisation des bits d'√©tat</p>
        </section>

        <section>
          <h2>9.2 Traitements d'erreurs</h2>
          <p><a href="https://en.cppreference.com/w/cpp/io/ios_base/iostate">üìö iostate (cppreference.com)</a></p>

          <iframe src="https://en.cppreference.com/w/cpp/io/ios_base/iostate" width="1900" height="800"></iframe>
        </section>

        <section>
          <h2>9.2 Traitements d'erreurs (exceptions)</h2>
          <pre style="width: 1800px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            #include &#60;iostream&#62; // std::cerr 
            #include &#60;fstream&#62;  // std::ifstream 
            
            int main () {
              std::ifstream file;
              file.exceptions(std::ifstream::failbit | std::ifstream::badbit);
              try {
                file.open("test.txt");
                while(!file.eof()) file.get();
                file.close(); 
              }
              catch (const std::ifstream::failure &e) {
                std::cerr << "Exception opening/reading/closing file" << std::endl;
              } 
              
              return 0;
            }
          </code></pre>
        </section>

        <section>
          <h2>9.2 E/S Format√©es ou non-format√©es</h2>
          <p><inline-code><highlight>ios::binary</highlight></inline-code> ‚áí s'assure que les donn√©es sont lues ou √©crites sans traduire √† la vol√©e des caract√®res sp√©ciaux (ex. les caract√®res de fin de ligne \r\n)</p>
          <!-- NOTE: we use html code here because auto-formating with << breaks the code -->
          <p><inline-code><highlight>&#60;&#60;</highlight></inline-code> ‚áí √âcriture format√©e (pour les fichiers textuels)</p>
          <p><inline-code><highlight>>></highlight></inline-code> ‚áí Lecture format√©e (pour les fichiers textuels)</p>
          <p>M√©thode <inline-code><highlight>write()</highlight></inline-code> ‚áí √âcriture non format√©e (pour les fichiers binaires)</p>
        </section>

        <section>
          <h2>9.2 M√©thodes de lecture de <span style="text-transform: lowercase;"><inline-code><highlight>std::istream</highlight></inline-code></span></h2>
          <h3>Lecture format√©e</h3>
          <p><inline-code><highlight>istream &operator>>(...)</highlight></inline-code></p>
          <p><inline-code><highlight>cin >> delta >> integer;</highlight></inline-code></p>
          <h3>Lecture non format√©e</h3>
          <p><inline-code><highlight>.get</highlight></inline-code> : lecture d'un seul caract√®re</p>
          <p><inline-code><highlight>.getline</highlight></inline-code> : lecture d'une suite de caract√®res</p>
          <p><inline-code><highlight>.ignore</highlight></inline-code> : lecture de caract√®res ¬´√† fond perdu¬ª</p>
          <p><inline-code><highlight>.peek</highlight></inline-code> : donne le prochain caract√®re sans l'extraire</p>
          <p><inline-code><highlight>.seekg</highlight></inline-code> : positionnement sur un flux</p>
          <p><inline-code><highlight>.read</highlight></inline-code> : lecture de n caract√®res</p>
        </section>

        <section>
          <h2>9.2 M√©thodes de lecture de <span style="text-transform: lowercase;"><inline-code><highlight>std::ostream</highlight></inline-code></span></h2>
          <h3>√âcriture format√©e</h3>
          <!-- NOTE: we use html code here because auto-formating with << breaks the code -->
          <p><inline-code><highlight>ostream &operator&#60;&#60;(...)</highlight></inline-code></p>
          <p><inline-code><highlight>cout << delta << integer;</highlight>
            </inline-code></p>
          <h3>√âcriture non format√©e</h3>
          <p><inline-code><highlight>.put</highlight></inline-code> : √©criture d'un seul caract√®re</p>
          <p><inline-code><highlight>.write</highlight></inline-code> : √©criture du contenu du tampon</p>
          <p><inline-code><highlight>.flush</highlight></inline-code> : vide le tampon de sortie</p>
          <p><inline-code><highlight>.tellp</highlight></inline-code> : positionnement courant sur le flux</p>
          <p><inline-code><highlight>.seekp</highlight></inline-code> : positionnement sur un flux</p>
        </section>

      </section>

      <!----------          9.3 Flux et std::string          ---------->

      <section>

        <section>
          <h2>9.3 Le flux <span style="text-transform: lowercase;"><inline-code><highlight>std::stringstream</highlight></inline-code></span></h2>
          <p>Les flux peuvent √™tre utilis√©s pour lire et √©crire des cha√Ænes de caract√®res</p>
          <p><inline-code><highlight></highlight>#include &#60;sstream&#62;</inline-code> ‚áí 3 classes :</p>
          <p>- <inline-code><highlight>istringstream</highlight></inline-code> : entr√©e (lecture)</p>
          <p>- <inline-code><highlight>ostringstream</highlight></inline-code> : sortie (√©criture)</p>
          <p>- <inline-code><highlight>stringstream</highlight></inline-code> : entr√©e/sortie (lecture/√©criture)</p>
        </section>

        <section><h2>9.3 La classe <span style="text-transform: lowercase;"><inline-code><highlight>std::string</highlight></inline-code></span></h2>
          <p>La biblioth√®que standard impl√©mente une classe <inline-code>
              <highlight>std::string</highlight>
            </inline-code></p>
          <p><inline-code>
              <highlight>#include &#60;string&#62;</highlight>
            </inline-code></p>
          <p>Sp√©cialisation d'un mod√®le : <inline-code>
              <hightlight>typedef basic_string&#60;char&#62; string;</hightlight>
            </inline-code></p>
          <br>
          <h3>Avantages</h3>
          <p>- Plus simple et plus s√ªre que les tableaux de caract√®res</p>
          <p>- Gestion automatique de la m√©moire</p>
          <p>- D√©finition de m√©thodes et d'op√©rateurs</p>
        </section>

        <section>
          <h2>9.3 La classe 9.3 La classe <span style="text-transform: lowercase;"><inline-code><highlight>std::string</highlight></inline-code></span></h2>
          <p><b>Op√©rateurs</b></p>
          <p>
            Affectation : <inline-code><highlight>=</highlight></inline-code>, Concat√©nation : <inline-code><highlight>+</highlight></inline-code> et <inline-code><highlight>+=</highlight></inline-code>, Comparaisons : <inline-code><highlight>==</highlight></inline-code> <inline-code><highlight>&lt;</highlight></inline-code> <inline-code><highlight>&gt;</highlight></inline-code> <inline-code><highlight>&lt;=</highlight></inline-code> <inline-code><highlight>&gt;=</highlight></inline-code></p>
          <p><b>M√©thodes</b></p>
          <p>- <inline-code>
              <highlight>size()</highlight>
            </inline-code> : renvoie le nombre de caract√®res</p>
          <p>- <inline-code>
              <highlight>length()</highlight>
            </inline-code> : renvoie le nombre de caract√®res</p>
          <p>- <inline-code>
              <highlight>capacity()</highlight>
            </inline-code> : taille possible sans r√©allocation</p>
          <p>- <inline-code>
              <highlight>empty()</highlight>
            </inline-code> : vrai si la cha√Æne est vide, faux sinon</p>
          <p>- <inline-code><highlight>find()</highlight></inline-code> : position de la cha√Æne <inline-code>s</inline-code> dans la cha√Æne courante √† partir de<inline-code>pos</inline-code></p>
          <p>- <inline-code><highlight>substr()</highlight></inline-code> : sous-cha√Æne de longueur <inline-code>length</inline-code> √† partir de<inline-code>start</inline-code></p>
          <p>- <inline-code><highlight>at()</highlight></inline-code> : acc√®s √† un caract√®re par son index</p>
          <p>- <inline-code><highlight>c_str()</highlight></inline-code> : renvoie un pointeur vers le tableau de caract√®res</p>
        </section>

        <section>
          <h2>9.3 Conversions entre <span style="text-transform: lowercase;"><inline-code>
                <highlight>std::string</highlight>
              </inline-code></span> et <span style="text-transform: lowercase;"><inline-code>
                <highlight>char *</highlight>
              </inline-code></span></h2>
          <pre style="width: 1400px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.7em;"
              data-line-numbers="">

              #include &#60;iostream&#62;
              #include &#60;string&#62;
              #include &#60;cstdio&#62;
              
              int main()
              {
                auto p = "Hello"; // const char *
                auto s = std::string(p);
                auto s2 = std::string("World!");
                std::cout << s << " " << s2 << std::endl;
                printf("%s %s\n", s, s2); // ‚ö†Ô∏è warning C4477: 'printf'...
                
                auto p2 = s2.c_str(); // const char *
                std::cout << p << " " << p2 << std::endl;
                printf("%s %s\n", p, p2);

                return 0;
              }
            </code></pre>
        </section>

        <section>
          <h2>9.3 Conversions avec les flux de cha√Æne</h2>
          <pre style="width: 1400px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.7em;"
              data-line-numbers="">

              #include &#60;iostream&#62;
              #include &#60;string&#62;
              #include &#60;sstream&#62;
              
              int main()
              {
                  std::ostringstream toto;
                  toto << 10;
                  auto texte = toto.str();
                  
                  std::istringstream titi("10");
                  int nombre;
                  titi >> nombre;
              
                  return 0;
              }
            </code></pre>
        </section>

        <section>
          <h2>Les flux (vue d'ensemble)</h2>
          <p><a href="https://en.cppreference.com/w/cpp/io#Stream-based_I.2FO">üìö Stream-based I/O
              (cppreference.com)</a></p>

          <iframe src="https://en.cppreference.com/w/cpp/io#Stream-based_I.2FO" width="1900" height="800"></iframe>
        </section>

      </section>

      <!----------          9.4 Conteneurs s√©quentiels          ---------->
      <section>

        <section>
          <h2>9.4 Standard Template Library (STL)</h2>
          <p>Biblioth√®que de classes et d'algorithmes g√©n√©riques (A. Stepanov)</p>
          <p>Impl√©ment√©e en C++</p>
          <p>Int√©gr√©e √† la proc√©dure de standardisation de C++</p>
          <p>Bas√©e sur les mod√®les de classes</p>
          <p><b>Contient</b></p>
          <p>- Conteneurs s√©quentiels</p>
          <p>- Conteneurs associatifs</p>
          <p>- It√©rateurs</p>
          <p>- Algorithmes</p>
          <p>- Objets fonctions (foncteurs)</p>
          <p>- Adaptateurs</p>
          <p>- Allocateurs</p>
        </section>

        <section>
          <h2>9.4 Les conteneurs</h2>
          <p>Les conteneurs sont des classes qui permettent de stocker des objets</p>
          <p>Ils sont d√©finis dans le namespace <inline-code>
              <highlight>std</highlight>
            </inline-code></p>
          <p>G√©rer les objets contenus : ajout, suppression (parfois tri, recherche, ...)</p>
          <p>Acc√©der aux objets contenus gr√¢ce aux it√©rateurs</p>
          <p>Les it√©rateurs permettent de parcourir une collection d'objets sans avoir √† se pr√©occuper de
            l'impl√©mentation</p>
          <p>‚áí Avoir une interface de manipulation commune pour les algorithmes g√©n√©riques de la STL (tri, recherche,
            remplacement, ...)</p>
        </section>

        <section>
          <h2>9.4 Les conteneurs</h2>
          <h3>2 types de conteneurs</h3>
          <br>
          <p><b>Conteneurs s√©quentiels</b></p>
          <p>Conteneurs dont les √©l√©ments sont ordonn√©s. Parcourir le conteneur suivant cet ordre et ins√©rer ou
            supprimer un √©l√©ment en un endroit explicitement choisi.</p>
          <p><inline-code>
              <highlight>vector</highlight>
            </inline-code>, <inline-code>
              <highlight>list</highlight>
            </inline-code>, <inline-code>
              <highlight>deque</highlight>
            </inline-code>, ...</p>
          <br>
          <p><b>Conteneurs associatifs</b></p>
          <p>Conteneurs dont les √©l√©ments sont identifi√©s par une cl√© et ordonn√©s suivant celle-ci. Pour ins√©rer un
            √©l√©ment, il n'est en th√©orie pas utile de pr√©ciser un emplacement.</p>
          <p><inline-code>
              <highlight>map</highlight>
            </inline-code>, ...</p>
        </section>

        <section>
          <h2>9.4 Les conteneurs s√©quentiels</h2>
          <p>Tableau dynamique contigu : <inline-code>
              <highlight>vector</highlight>
            </inline-code></p>
          <p>Tableau statique contigu : <inline-code>
              <highlight>array</highlight>
            </inline-code></p>
          <p>File √† double entr√©e : <inline-code>
              <highlight>deque</highlight>
            </inline-code></p>
          <p>Liste doublement chain√©e : <inline-code>
              <highlight>list</highlight>
            </inline-code></p>
          <p>Liste simplement chain√©e : <inline-code>
              <highlight>forward_list</highlight>
            </inline-code></p>
          <p>File : <inline-code>
              <highlight>queue</highlight>
            </inline-code>, <inline-code>
              <highlight>priority_queue</highlight>
            </inline-code></p>
          <p>Pile : <inline-code>
              <highlight>stack</highlight>
            </inline-code></p>
        </section>

        <section>
          <h2>9.4 M√©thodes courantes</h2>
          <p><inline-code><highlight>clear()</highlight></inline-code> : vide le conteneur</p>
          <p><inline-code><highlight>size()</highlight></inline-code> : retourne le nombre d'√©l√©ments</p>
          <p><inline-code><highlight>empty()</highlight></inline-code> : teste si le conteneur est vide</p>
          <p><inline-code><highlight>push_back(...)</highlight></inline-code> : ajoute un √©l√©ment √† la fin</p>
          <p><inline-code><highlight>push_front(...)</highlight></inline-code> : ajoute un √©l√©ment au d√©but</p>
          <p><inline-code><highlight>front()</highlight></inline-code> : renvoie le 1er √©l√©ment</p>
          <p><inline-code><highlight>pop_front()</highlight></inline-code> : supprime le premier √©l√©ment</p>
          <p><inline-code><highlight>insert()</highlight></inline-code> : ins√®re un √©l√©ment</p>
          <p><inline-code><highlight>erase()</highlight></inline-code> : supprime un √©l√©ment</p>
        </section>

        <section>
          <h2>9.4 Exemple</h2>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.7em;"
            data-line-numbers="">

            #include &#60;iostream&#62;
            #include &#60;vector&#62;
            #include &#60;string&#62;

            int main()
            {
              std::vector&#60;std::string&#62; vect;
              vect.push_back("Introduction");
              vect.push_back("une phrase");
              vect.push_back("Conclusion");
              
              for (const auto &elem : vect)
                std::cout << elem << std::endl;
                
              for (int i = 0; i < vect.size(); ++i)
                std::cout << vect[i] << std::endl;
                
              return 0;
            }
          </code></pre>
        </section>

        <section>
          <h2>9.4 Exemple</h2>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.7em;"
            data-line-numbers="">

            #include &#60;list&#62;
            
            int main()
            {
              std::list&#60;int&#62; lst;
              lst.push_back(1); // 1
              lst.push_front(0); // 0 1
              lst.insert(lst.begin(), 2); // 2 0 1
              lst.insert(lst.end(), 3); // 2 0 1 3
              lst.pop_front(); // 0 1 3
              
              return 0;
            }
          </code></pre>
        </section>

        <section>
          <h2>9.4 Exemple</h2>
          <pre style="width: 1800px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.7em;"
            data-line-numbers="">

            #include &#60;iostream&#62;
            #include &#60;array&#62;
            
            int main()
            {
              std::array&#60;int, 3&#62; a1{ {10,11,12} };
              // std::array&#60;int, 3&#62; a1 = { 10,11,12 };
            
              for (int i = 0; i < a1.size(); ++i)
              {
                std::cout << a1[i] << std::endl; // ‚ö†Ô∏è no range check
                std::cout << a1.at(i) << std::endl; // ‚úÖ range check (throws exception)
              }
            
              return 0;
            }
          </code></pre>
        </section>

        <section>
          <h2>9.4 Destruction</h2>
          <h3>Faut-il effacer ce qui est stock√© dans un vecteur ?</h3>
          <p>‚áí Tout d√©pend de la nature de ce qui est stock√© dans le <inline-code>std::vector</inline-code></p>
          <br>
          <p><b>Objets</b></p>
          <p>Les objets sont d√©truits lors du retrait (pop), ou lorsque le vecteur est d√©truit</p>
          <br>
          <p><b>Pointeurs</b></p>
          <p>Les pointeurs sont d√©truits lorsque le vecteur est d√©truit <b><warning>mais pas la m√©moire allou√©e !</warning></b></p>
          <p>‚áí Il faut <inline-code>delete</inline-code> chaque pointeur stock√©, sinon il y aura une fuite de m√©moire.</p>
        </section>

        <section>
          <h2>9.4 Imbrication de conteneurs</h2>
          <p>Il est possible d'imbriquer les conteneurs de la STL</p>
          <p>On peut ainsi, par exemple, cr√©er un vecteur de listes de cha√Ænes de caract√®res</p>
          <br>
          <p><b>Exemple</b></p>
          <p><inline-code>
              <highlight>std::vector&#60;std::list&#60;std::string&#62;&#62;</highlight>
            </inline-code></p>
          <br>
          <p>La d√©finition d'un type interm√©diaire peut augmenter la lisibilit√© :</p>
          <p><inline-code>
              <highlight>typedef std::list&#60;std::string&#62; list_string;</highlight>
            </inline-code></p>
          <p><inline-code>
              <highlight>typedef std::vector&#60;list_string&#62; vector_list_string;</highlight>
            </inline-code></p>
        </section>

        <section>
          <h2>9.4 Imbrication de conteneurs</h2>
          <p>Des <inline-code>std::vector</inline-code> imbriqu√©s simulent des tableaux √† plusieurs dimensions</p>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            #include &#60;iostream&#62;
            #include &#60;vector&#62;

            typedef vector&#60;double&#62; Line;
            typedef vector&#60;Line&#62; Matrix;
            
            Matrix m(5); // 5 rows of size 0 initially
            for(int i=0; i<5; i++)
            {
              m[i].resize(5); // rows are now of size 5
              for(int j=0; j<5; j++)
              {
                if (i==j) m[i][j] = 1;
                else m[i][j] = 0;
              }
            }
          </code></pre>
        </section>

      </section>

      <!----------          9.5 It√©rateurs          ---------->
      <section>

        <section>
          <h2>9.5 Les it√©rateurs</h2>
          <p>Les it√©rateurs sont une <b>g√©n√©ralisation des pointeurs</b></p>
          <p>D√©finis dans le namespace <inline-code>
              <highlight>std</highlight>
            </inline-code></p>
          <p>Utilis√©s par les algorithmes de la STL</p>
          <p>Utiliser les conteneurs <b>de fa√ßon uniforme</b></p>
          <p>Sp√©cifier une position √† l'int√©rieur d'un conteneur. Ils peuvent √™tre incr√©ment√©s, et d√©r√©f√©renc√©s (avec
            *); deux it√©rateurs peuvent √™tre compar√©s.</p>
          <p><b>Tous les conteneurs disposent des m√©thodes suivantes</b></p>
          <p><inline-code>
              <highlight>begin()</highlight>
            </inline-code> : renvoie un it√©rateur pointant sur le 1er √©l√©ment</p>
          <p><inline-code>
              <highlight>end()</highlight>
            </inline-code> : renvoie un it√©rateur pointant <b>APRES</b> le dernier √©l√©ment</p>
          <p>
            <warning>‚ö†Ô∏è On ne peut donc pas d√©r√©f√©rencer l'it√©rateur renvoy√© par <inline-code>
                <highlight>end()</highlight>
              </inline-code></warning>
          </p>
        </section>

        <section>
          <h2>9.5 Les it√©rateurs</h2>
          <h3>D√©clarations</h3>
          <p><inline-code><highlight>std::vector&#60;double&#62;::iterator it;</highlight></inline-code></p>
          <br>
          <p>Un it√©rateur peut s'initialiser gr√¢ce aux m√©thodes <inline-code><highlight>begin()</highlight></inline-code>, <inline-code><highlight>end()</highlight></inline-code>, ou <inline-code><highlight>find()</highlight></inline-code> :</p>
          <p>1) <inline-code><highlight>std::vector&#60;double&#62;::iterator it(vect.begin());</highlight></inline-code></p>
          <p>2) <inline-code><highlight>auto it = vect.begin();</highlight></inline-code></p>
        </section>

        <section>
          <h2>9.5 Exemple</h2>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            #include &#60;iostream&#62;
            #include &#60;list&#62;
            
            int main()
            {
              std::list&#60;int&#62; lst;
            
              std::list&#60;int&#62;::iterator it;
              for (it = lst.begin(); it != lst.end(); ++it)
                std::cout << *it << std::endl; // *it = each element
              
              // C++11
              auto it = lst.begin();
              for (; it != lst.end(); ++it)
                std::cout << *it << std::endl;

              // C++11 range-based for loop
              for (auto &elem : lst)
                std::cout << elem << std::endl; // elem = each element
            }
          </code></pre>
        </section>
      </section>

      <!----------          9.6 Conteneurs associatifs          ---------->
      <section>

        <section>
          <h2>9.6 Conteneurs associatifs</h2>
          <p>Les conteneurs associatifs sont des conteneurs qui stockent des √©l√©ments sous forme de paires cl√©/valeur</p>
          <p>Les cl√©s permettent d'acc√©der aux valeurs</p>
          <p>Les conteneurs associatifs sont ordonn√©s selon la cl√©</p>
          <br>
          <p><inline-code><highlight>std::map</highlight></inline-code>, <inline-code><highlight>std::multimap</highlight></inline-code>, <inline-code><highlight>std::set</highlight></inline-code>, <inline-code><highlight>std::multiset</highlight></inline-code>, ...</p>
          <br>
          <p>Ces conteneurs utilisent <inline-code><highlight>std::pair&#60;T1, T2&#62;</highlight></inline-code> pour stocker les paires cl√©/valeur</p>
        </section>

        <section>
          <h2>9.6 Tables associatives</h2>
          <p>G√©n√©ralisation des tableaux : les indices peuvent √™tre non entiers</p>
          <p>- Tableau que l'on pourrait indicer par des cha√Ænes de caract√®res et √©crire par exemple <inline-code>
              <highlight>moyenne["Informatique"]</highlight>
            </inline-code></p>
          <p>- On parle d'association "cl√© - valeur"</p>
          <p>Les tables associatives sont d√©finies dans <inline-code>
              <highlight>&#60;map&#62;</highlight>
            </inline-code></p>
          <p>Elles n√©cessitent 2 types pour leur d√©claration : le type des "cl√©s" (les index) et le type des √©l√©ments
            index√©s</p>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.7em;"
            data-line-numbers="">

            #include &#60;string&#62;
            #include &#60;map&#62;
            
            std::map&#60;std::string, double&#62; moyenneParBranche;  // Unique key
            std::multimap&#60;std::string, double&#62; notesParBranche; // Duplicated keys
            </code></pre>
        </section>

        <section>
          <h2>9.6 Exemple</h2>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.7em;"
            data-line-numbers="">

            #include &#60;string&#62;
            #include &#60;map&#62;
            #include &#60;iostream&#62;
            
            int main()
            {
              std::map&#60;std::string, double&#62; moyenne;
              moyenne["Informatique"] = 5.5;
              moyenne["Physique"] = 4.5;
              
              // if->first to access the key, if->second to access the value
              for (auto it = moyenne.begin(); it != moyenne.end(); ++it)
                std::cout << "En " << it->first << ", j'ai " << it->second <<
                           " de moyenne." << std::endl ;
              
              std::cout << "Ma moyenne en Informatique est de ";
              std::cout << moyenne.find("Informatique")->second << std::endl;

              return 0;
            }
          </code></pre>
        </section>

        <section>
          <h2>9.6 Exemple</h2>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">

            // First element of map moyenne
            auto it = moyenne.begin();

            // Found element in map (or end() if not found)
            auto it2 = moyenne.find("Informatique");

            // End of map (after last element)
            // ‚ö†Ô∏è it2 == it3 if not found
            auto it3 = moyenne.end();

          </code></pre>
        </section>

        <section>
          <h2>9.6 Recherche</h2>
          <p>
            <warning>‚ö†Ô∏è Attention :</warning> le simple fait d'acc√©der √† une cl√© via
            <inline-code>operator[]</inline-code> ins√®re cette cl√© (avec la valeur par d√©faut pour le type
            <inline-code>T</inline-code>)
          </p>
          <p>‚áí <inline-code>operator[]</inline-code> n'est donc pas adapt√© pour v√©rifier si une cl√© est pr√©sente dans
            une <inline-code>map</inline-code></p>
          <br>
          <p>
            <success>‚úÖ Pour chercher une clef :</success> utiliser la m√©thode <inline-code>find()</inline-code>
          </p>
        </section>

        <section>
          <h2>9.6 <span style="text-transform: lowercase;"><inline-code>
                <highlight>std::pair&#60;T1, T2&#62;</highlight>
              </inline-code></span></h2>
          <p>Dans le code <inline-code>auto it = moyenne.begin();</inline-code>, <inline-code>it</inline-code> est un
            it√©rateur sur une <inline-code>map</inline-code></p>
          <p>Il est possible de d√©r√©f√©rencer l'it√©rateur pour acc√©der √† la paire cl√©/valeur avec
            <inline-code>(*it)</inline-code>
          </p>
          <p><inline-code>(*it)</inline-code> est de type <inline-code>std::pair&#60;const std::string,
              double&#62;</inline-code></p>
          <p>Une paire est une structure contenant 2 √©l√©ments pouvant √™tre de types diff√©rents</p>
          <p>Certains algorithmes de la STL retournent des paires. La m√©thode <inline-code>find()</inline-code>, par
            exemple, retourne la position de l'√©l√©ment trouv√© et un bool√©en indiquant s'il a √©t√© trouv√© ou non</p>
        </section>

        <section>
          <h2>9.6 Exemple</h2>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.7em;"
            data-line-numbers="">

            // Not needed in practice,
            // because it is implicit when using e.g. <inline-code>&#60;vector&#62;</inline-code>
            #include &#60;pair&#62;
            #include &#60;iostream&#62;
            #include &#60;string&#62;
            
            int main()
            {
              auto p =  std::make_pair(8, "coeur");
              std::cout << p.first << ' ' << p.second << std::endl;
              
              return 0;
            }
          </code></pre>
        </section>

        <section>
          <h2>9.6 Exemple</h2>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.7em;"
            data-line-numbers="">

            #include &#60;iostream&#62;
            #include &#60;map&#62;
            
            int main()
            {
              std::multimap<std::string, double> notes;
            
              // ‚ö†Ô∏è Indices do not work with multimap!
              // moyenne["Informatique"] = 5.5;
              
              notes.insert(std::pair<std::string, double>	("Informatique", 5.5));
              notes.insert(std::pair<std::string, double>	("Informatique", 4.0)); 
            
              for (auto it = notes.begin(); it != notes.end(); ++it)
                std::cout << "En " << it->first << ", j'ai " << it->second <<
                     " de moyenne." << std::endl;

              return 0;              
            }
          </code></pre>
        </section>

        <section>
          <h2>9.6 Les conteneurs</h2>
          <p><a href="https://en.cppreference.com/w/cpp/container">üìö Containers library (cppreference.com)</a></p>

          <iframe src="https://en.cppreference.com/w/cpp/container" width="100%" height="800"></iframe>
        </section>

      </section>

      <!---          9.7 Les smart pointers          --->
      <section>

        <section>
          <h2>9.7 Les smart pointers</h2>
          <p>Les smart pointers sont des classes qui g√®rent la m√©moire de mani√®re automatique</p>
          <p>Utiliser <inline-code><highlight>#include &#60;memory&#62;</highlight></inline-code></p>
          <p>D√©finis dans le namespace <inline-code><highlight>std</highlight></inline-code></p>
          <p>G√©rer la m√©moire de mani√®re plus s√ªre et plus efficace que les pointeurs bruts</p>
          <br>
          <p><inline-code><highlight>std::unique_ptr</highlight></inline-code> : pointeur unique. Lorsque le <inline-code>unique_ptr</inline-code> devient hors de port√©e, l'objet point√© est √©galement d√©truit</p>
          <p><inline-code><highlight>std::shared_ptr</highlight></inline-code> : pointeur partag√©. Plusieurs <inline-code>shared_ptr</inline-code> peuvent pointer vers le m√™me objet. Lorsque le dernier <inline-code>shared_ptr</inline-code> devient hors de port√©e, l'objet point√© est √©galement d√©truit</p>
          <p><inline-code><highlight>std::weak_ptr</highlight></inline-code> : pointeur faible. Il permet de r√©f√©rencer un objet sans en prendre possession. Il est utilis√© pour √©viter les r√©f√©rences circulaires entre <inline-code>shared_ptr</inline-code></p>
        </section>

        <section>
          <h2>Exemple avec les <span style="text-transform: lowercase;"><inline-code>
                <highlight>unique_ptr</highlight>
              </inline-code></span> </h2>

          <pre style="width: 1600px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.6em;"
              data-line-numbers="">

              #include &#60;iostream&#62;
              #include &#60;memory&#62;
              
              int main()
              {
                // Raw pointers
                {
                  auto ptr = new int(5); // dynamic allocation
                  std::cout << *ptr; // 5
                  delete ptr; // ‚ö†Ô∏è free memory to avoid memory leak
                  ptr = nullptr; // avoid dangling pointer  
                }

                // Smart pointers
                {
                  auto s_ptr = std::unique_ptr<int>(new int(5)); // dynamic allocation
                  std::cout << *s_ptr; // 5
                  // ‚úÖ No need to delete, memory is automatically freed when ptr goes out of scope
                }

                return 0;
              }
            </code></pre>
        </section>

        <section>
          <h2>Exemple avec les <span style="text-transform: lowercase;"><inline-code><highlight>unique_ptr</highlight></inline-code></span></h2>

          <pre style="width: 1600px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.6em;"
              data-line-numbers="">

              #include &#60;iostream&#62;
              #include &#60;memory&#62;
              
              int main()
              {
                // Smart pointers
                {
                  auto s_ptr = std::unique_ptr<int>(new int(5)); // dynamic allocation
                  std::cout << *s_ptr; // 5

                  // ‚õî error: use of deleted function...
                  auto s_ptr1 = std::unique_ptr<int>(s_ptr);

                  // ‚õî error: use of deleted function...
                  auto s_ptr2 = s_ptr; // ‚õî error: use of deleted function...
                }

                return 0;
              }
            </code></pre>
        </section>

        <section>
          <h2>Exemple avec les <span style="text-transform: lowercase;"><inline-code><highlight>shared_ptr</highlight></inline-code></span></h2>

          <pre style="width: 1600px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.6em;"
              data-line-numbers="">

              #include &#60;iostream&#62;
              #include &#60;memory&#62;
              
              int main()
              {
                // Raw pointers
                {
                  auto ptr = new int(5); // dynamic allocation
                  std::cout << *ptr; // 5
                  delete ptr; // ‚ö†Ô∏è free memory to avoid memory leak
                  ptr = nullptr; // avoid dangling pointer  
                }

                // Smart pointers
                {
                  auto s_ptr = std::shared_ptr<int>(new int(5)); // dynamic allocation
                  std::cout << *s_ptr; // 5
                  // ‚úÖ Memory is automatically freed when ptr goes out of scope
                }

                return 0;
              }
            </code></pre>
        </section>

        <section>
          <h2>Particularit√© des <span style="text-transform: lowercase;"><inline-code>
                <highlight>shared_ptr</highlight>
              </inline-code></span> </h2>
          <p>On ne peut pas affecter directement une adresse √† un <inline-code>shared_ptr</inline-code>. Il faut
            utiliser la m√©thode <inline-code>reset()</inline-code> pour lui assigner un nouvel objet allou√©
            dynamiquement</p>
          <p>Plusieurs <inline-code>shared_ptr</inline-code> peuvent pointer vers le m√™me objet. Ils partagent la
            propri√©t√© de l'objet point√©</p>
          <p>En particulier, les <inline-code>shared_ptr</inline-code> peuvent √™tre copi√©s entre eux</p>
          <br>
          <p>
            <warning>‚ö†Ô∏è Attention :</warning> il faut faire attention √† ne pas cr√©er de r√©f√©rences circulaires entre
            <inline-code>shared_ptr</inline-code>
          </p>
          <p>‚áí Utiliser <inline-code>std::weak_ptr</inline-code> pour √©viter les r√©f√©rences circulaires</p>
          <br>
          <p>
            <warning>‚ö†Ô∏è Attention :</warning> un <inline-code>shared_ptr</inline-code> ne peut pas pointer sur un
            tableau d'objets !
          </p>
          <p>‚áí Il faut utiliser <inline-code>std::unique_ptr</inline-code> pour cela</p>
        </section>

        <section>
          <h2>Exemple avec les <span style="text-transform: lowercase;"><inline-code>
                <highlight>shared_ptr</highlight>
              </inline-code></span> </h2>

          <pre style="width: 1600px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.6em;"
              data-line-numbers="">

              #include &#60;iostream&#62;
              #include &#60;memory&#62;

              int main()
              {
                std::shared_ptr<Forme2D> sp1;
                {
                  auto circle = new Circle(2);
                  auto sp2 = std::shared_ptr<Forme2D>(circle);
                  // üìå circle has now 1 reference (sp2)

                  // ‚úÖ OK
                  sp1 = sp2;
                  // üìå circle has now 2 references (sp2 and sp1)
                  ...
                }
                // üìå circle has 1 reference (sp2) 
                ...
                return 0;
              }
              // üìå circle has 0 reference and is deleted                
            </code></pre>
        </section>

      </section>

    </div>
  </div>

  <!----------          CONTENT          ---------->

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,
      width: 1920,
      height: 1080,
      transition: "none",
      center: false,
      slideNumber: 'c/t',

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>