<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>HE-Arc - 1242.2 Langage C++ - Chapitre 1 - De C √† C++</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/hearc.css" id="theme">
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="https://www.he-arc.ch/wp-content/uploads/2021/12/cropped-hearc-icon-192x192.png"
    type="image/vnd.microsoft.icon" />

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/vs.css" id="highlight-theme">
</head>

<body>
  <img id="logo-hearc" src="./medias/logo_he-arc.png" alt="Logo HE-ARC">
  <img id="logo-hesso" src="./medias/logo_hes-so.png" alt="Logo HES-SO">
  <p id="course-infos">1242.2 Langage C++ - 2025-2026</p>

  <div class="reveal">
    <div class="slides">

      <!----------          TITLE          ---------->
      <section>
        <h1>
          Chapitre 1
        </h1>
        <h2>
          De C √† C++
        </h2>
        <div class="container">
          <div class="col-left">
            <p>1. Introduction</p>
            <p>2. Espaces de noms</p>
            <p>3. Entr√©es/sorties standards</p>
            <p>4. Passage de param√®tres</p>
            <p>5. Valeurs par d√©faut des param√®tres</p>
          </div>
          <div class="col-right">
            <p>6. Surcharge des fonctions</p>
            <p>7. Allocation dynamique</p>
            <p>8. La classe <inline-code>std::string</inline-code></p>
            <p>9. Divers : auto, range-for. etc.</p>
            <p>10. Biblioth√®que standard</p>
          </div>
        </div>
      </section>

      <!----------          INTRODUCTION          ---------->
      <section>

        <section>
          <h2>1.1 Historique du langage</h2>
          <p><b>1979</b> - <highlight>C avec des classes</highlight> : premi√®res extensions au langage C</p>
          <p><b>1983</b> - le nom C++ est cr√©√© pour "C incr√©ment√©"</p>
          <p><b>1998</b> - Le langage C++ est normalis√©e par l'ISO</p>
          <p><b>2011</b> - <highlight>C++11, C++ moderne</highlight> : nouvelle norme du langage</p>
          <p><b>2014</b> - C++14 : mise √† jour mineure</p>
          <p><b>2017</b> - C++17 : mise √† jour majeure (am√©lioration des templates, etc)</p>
          <p><b>2020</b> - C++20 : mise √† jour majeure (module, coroutines, etc.)</p>
          <p><b>2023</b> - C++23 : mise √† jour mineure, version courante</p>
          <p><b>2026</b> - version en cours de d√©veloppement</p>
          <br><br>
          <p><a href="https://en.wikipedia.org/wiki/C++#Standardization">üìö Historique de C++ (Wikipedia)</a></p>
        </section>

        <section>
          <h2>1.1 Introduction</h2>
          <p>
            <warning>‚ö†Ô∏è Ce cours ne revient pas sur le C !</warning>
          </p>
          <br>
          <p><s>Le C++ est une extension du langage C</s> (un compilateur C++ peut compiler du code C)</p>
          <p>Le C++ est libre de droit</p>
          <p>Au del√† de ~50'000 lignes de code, le C ne suffit plus</p>
        </section>

        <section>
          <h2>1.1 C++ est-il un langage objet ?</h2>
          <h3>Oui</h3>
          <p>C++ contient la notion de classe, d'instances, d'h√©ritage, etc.</p>
          <br>
          <h3>Non</h3>
          <p>C++ est surtout un langage multiparadigme</p>
          <p>C++ est enti√®rement compatible avec C qui n'est pas un langage objet</p>
          <p>On peut √©crire un programme ¬´ C++ ¬ª sans jamais utiliser la notion d'objet</p>
        </section>

        <section>
          <h2>1.1 Lien avec C</h2>
          <p>Pour programmer en C++, il ¬´ faut ¬ª conna√Ætre le langage C (notions & syntaxe)</p>
          <p>En C++, il est possible :</p>
          <ul>
            <li>de ne pas du tout utiliser les objets (on fait du C)</li>
            <li>de toujours utiliser les objets (on fait du C++ pur)</li>
            <li>de m√©langer des objets avec de la programmation non-objet</li>
          </ul>
          <br>
          <p>Le C++ peut ne pas √™tre "propre" : il h√©rite du C, de notions inutiles en POO</p>
          <br>
          <p>
            <error>‚õî √âviter de m√©langer du C avec du C++</error>
          </p>
          <p>
            <success>‚úÖ Pr√©f√©rer le C++ pur</success>
          </p>
        </section>

        <section>
          <h2>Pourquoi le C++</h2>
          <iframe src="https://www.tiobe.com/tiobe-index/" width="1600px" height="800px"></iframe>
        </section>

        <section>
          <h2>1.1 Un premier exemple</h2>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.4em;"
            data-line-numbers="">

            #include &#60;iostream&#62;
            
            int main()
            {
              std::cout << "Hello world++!" << std::endl;

              return 0;
            }</code></pre>

          <br>
          <p>Fonctionnalit√©s avanc√©es accessibles avec la biblioth√®que standard C++</p>
          <p><inline-code>std</inline-code> Espace de noms (namespace)</p>
          <p><inline-code>::</inline-code> Op√©rateur de port√©e</p>
          <p><inline-code>cout</inline-code> Flux de sortie</p>
          <p><inline-code><<</inline-code> Op√©rateur d'insertion
        </section>

        <section>
          <h2>1.1 D√©claration de variables</h2>
          <p>Les variables peuvent √™tre d√©clar√©es n'importe o√π (comme en C99)</p>

          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">

            #include &#60;iostream&#62;

            int main()
            {
                for (int i = 0; i < 3; ++i)
                {
                    int x = i * 2;
                    std::cout << x << std::endl;
                }

                return 0;
            }
          </code></pre>
          
          <br>
          
          <h3><success>‚úÖ Initialiser les variables √† la d√©claration</success></h3>
        </section>

        <section>
          <h2>1.1 Bool√©ens</h2>

          <p>Une variable de type <inline-code>bool</inline-code> a 2 valeurs : <inline-code>true</inline-code> et
            <inline-code>false</inline-code>
          </p>

          <br>

          <div class="container">
            <div class="col-left">
              <u><b><p>Conversions avec <inline-code>int</inline-code></p></b></u>
              <p><inline-code>true</inline-code> : 1</p>
              <p><inline-code>false</inline-code> : 0</p>
              <p>Entier non-nul : <inline-code>true</inline-code></p>
              <p>0 : <inline-code>false</inline-code></p>
            </div>
            <div class="col-right">
              <u><b><p>Conversions avec les pointeurs</p></b></u>
              <p>pointeur non-nul : <inline-code>true</inline-code></p>
              <p>pointeur nul : <inline-code>false</inline-code></p>
            </div>
          </div>
          <br>
          <p>
            <success>‚úÖ Ne pas utiliser ces conversions implicites (lisibilit√©)</success>
          </p>
          <p><inline-code>if (x != 0)</inline-code> plut√¥t que <s><inline-code>if (x)</inline-code></s></p>
          <p><inline-code>if (ptr != nullptr)</inline-code> plut√¥t que <s><inline-code>if (ptr)</inline-code></s></p>
        </section>

      </section>

      <!----------          ESPACES DE NOMS          ---------->
      <section>

        <section>
          <h2>1.2 Espace de noms</h2>
          <p>Grands projets ‚áí risque de collision de noms (variables et fonctions)</p>
          <br>
          <success>‚úÖ Confiner les noms d'un module dans un <highlight>espace de noms</highlight> (namespace)</success>
          <br><br>
          <p><inline-code>namespace XX{...}</inline-code> : d√©finit un nouvel espace de noms</p>
          <p><inline-code>namespace XX::YY{...}</inline-code> : nouvel espace de noms imbriqu√©s (C++17)</p>
          <p><inline-code>using namespace XX</inline-code> : ouvre l'espace de noms XX</p>
          <p><inline-code>::</inline-code> : op√©rateur de r√©solution de port√©e</p>
        </section>

        <section>
          <h2>1.2 Espace de noms - Exemple</h2>

          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.6em;"
            data-line-numbers="">
            
              namespace language::english
              {
                std::string colors[] = {"White", "Red", "Black"};
                void colorName(int index)
                {
                  std::cout << "The color is: " << colors[index] << std::endl;
                }
              }

              namespace language
              {
                namespace french
                {
                  std::string colors[] = {"Blanc", "Rouge", "Noir"};
                  void colorName(int index)
                  {
                    std::cout << "La couleur est : " << colors[index] << std::endl;
                  }
                }
              }
          
          </code></pre>
        </section>

        <section>
          <h2>1.2 Espace de noms - Exemple</h2>

          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.4em;"
            data-line-numbers="">            

              using namespace language;

              int main()
              {
                // GCC: error: 'colorName' was not declared in this scope
                // colorName(1);

                english::colorName(1);

                {
                  using namespace french;
                  colorName(1); // -> "Rouge"
                }

                using namespace english;
                colorName(1);         // -> "Red"
                french::colorName(1); // -> "Rouge"

                using namespace french;

                // GGC: error: call of overloaded 'colorName(int)' is ambiguous
                // colorName(1);

                return 0;
              }
          
          </code></pre>
        </section>

      </section>

      <!----------          Entr√©es/sorties standards          ---------->
      <section>

        <section>
          <h2>1.3 Entr√©es / Sorties</h2>
          <h3>Entr√©es / Sorties avec les variables pr√©d√©finies</h3>
          <p><inline-code>std::cin</inline-code> est une source de flux de donn√©es, en g√©n√©ral <highlight>le clavier
            </highlight>
          </p>
          <p><inline-code>std::cout</inline-code> est une destination de flux de donn√©es, en g√©n√©ral <highlight>l'√©cran
            </highlight>
          </p>
          <br>
          <h3>On utilise les op√©rateurs</h3>
          <p><inline-code>>></inline-code> extraction d'un flux source</p>
          <p><inline-code><<</inline-code> insertion dans un flux destination</p>
          <br>
          <h3>Exemple</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">
            #include &#60;iostream&#62;

            ...
            
            int n;
            std::cin >> n; // Read from keyboard
            std::cout << "val " << n; // Print to screen
          </code></pre>
        </section>

        <section>
          <h2>1.3 Entr√©es / Sorties</h2>
          <p>Inclure <inline-code>iostream</inline-code></p>
          <p>Accessibles dans l'espace de noms <inline-code>std</inline-code></p>
          <br>
          <h3>Exemples</h3>

          <div class="container">
            <div class="col-left">
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.2em;"
                data-line-numbers="">
                #include &#60;iostream&#62;
    


                int main()
                {
    
                  ...
               
                  std::cout << "val " << n; // Print to screen
                }
              </code></pre>
            </div>
            <div class="col-right">
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.2em;"
                data-line-numbers="">
                #include &#60;iostream&#62;
    
                using namespace std;
    
                int main()
                {
    
                  ...
               
                  cout << "val " << n; // Print to screen
                }
              </code></pre>
            </div>
          </div>

          <br>
          <p><a href="https://en.cppreference.com/w/cpp/io">üìö Input/output library (cppreference)</a></p>

        </section>

        <section>
          <h2>1.3 Manipulateurs d'E/S standard</h2>
          <h3>Les manipulateurs permettent de modifier un flux</h3>
          <p><inline-code>std::endl</inline-code> : fin de ligne</p>
          <p><inline-code>std::dec</inline-code>, <inline-code>std::oct</inline-code>,
            <inline-code>std::hex</inline-code> : changement de base
          </p>
          <p><inline-code>std::[no]uppercase</inline-code> : changement de casse</p>
          <p><inline-code>std::[no]showpos</inline-code> : force l'affichage du signe +</p>
          <p><inline-code>std::[no]boolalpha</inline-code> : affichage bool√©en (persistant)</p>

          <h3>Exemples</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">
            #include &#60;iostream&#62;

            ...

            int j = 10;
            std::cout << std::hex << std::nouppercase << j << std::endl;
            std::cout << std::hex << std::uppercase << j << std::endl;
            std::cout << std::dec << std::showpos << j << std::endl;
          </code></pre>
        </section>

        <section>
          <h2>1.3 Manipulateurs d'E/S standard</h2>
          <p>
            <warning>‚ö†Ô∏è Attention : </warning>les manipulateurs qui prennent des arguments appartiennent √† la
            biblioth√®que <inline-code>iomanip</inline-code>
          </p>
          </p>
          <br>
          <p><inline-code>setprecision(int)</inline-code> : nombre de chiffres significatifs</p>
          <p><inline-code>fixed</inline-code> : repr√©sentation √† virgule fixe</p>
          <p><inline-code>scientific</inline-code> : repr√©sentation scientifique</p>
          <p><inline-code>defaultfloat</inline-code> : repr√©sentation par d√©faut</p>
          <p><inline-code>setw(int)</inline-code> : nombre de caract√®res utilis√©s</p>
          <p><inline-code>setfill(char)</inline-code> : caract√®re de remplissage</p>
          <br><br>
          <p><a href="https://en.cppreference.com/w/cpp/io/manip">üìö Input/output manipulators (cppreference)</a></p>
        </section>

        <section>
          <h2>1.3 Manipulateurs d'E/S standard</h2>
          <h3>Contr√¥ler l'√©tat du flux d'entr√©e et agir</h3>
          <p><inline-code>cin.fail()</inline-code> : probl√®me dans le flux d'entr√©e, saisie incorrecte</p>
          <p> <inline-code>istream& ignore(streamsize n=1, int delim = EOF)</inline-code> : vide le buffer d'entr√©e</p>
          <br>
          <p>
            <warning>‚ö†Ô∏è Attention : </warning>il faut utiliser <inline-code>clear()</inline-code> avant d'utiliser <inline-code>ignore()</inline-code>
            pour remettre le flux d'entr√©e dans un √©tat correct
          </p>
        </section>

        <section>
          <h2>1.3 Manipulateurs d'E/S standard</h2>
          <h3>Exemple</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">

            int N = 0;
            std::cout << "Entrez un chiffre entre 1 et 6 : " ;
            while ( !( std::cin >> N ) || N < 1 || N > 6 )
            {
              if ( std::cin.fail() ) 
              { 
                std::cout << "Saisie incorrecte, recommencez : ";    
                std::cin.clear(); 
                std::cin.ignore(256, '\n' ); 
              } 
              else
              {
                std::cout << "Le chiffre n'est pas entre 1 et 6: ";
              } 
            }</code></pre>
          <br>
          <h3>Affichage</h3>
          <pre style="width: 1400px;"><code
              class="shell"
              data-trim
              data-noescape
              style="font-size: 1.2em;">
  
              Entrez un chiffre entre 1 et 6 : abcdef 
              Saisie incorrecte, recommencez : -3 
              Le chiffre n'est pas entre 1 et 6: 17 
              Le chiffre n'est pas entre 1 et 6: 5
              </code></pre>
        </section>

                <section>
          <h2>1.3 Entr√©es / Sorties (C++23)</h2>
          <p>Inclure <inline-code>print</inline-code></p>
          <h3>Exemple</h3>

            <pre style="width: 1400px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.6em;"
              data-line-numbers="">

              #include &#60;print&#62;
              
              // C++20: std::format and {:.2} instead of std::setprecision
              double dbl = 3.1415926535897932384626433832795;
              std::cout << std::format("{:.2f}", dbl) << std::endl;
              std::cout << std::format("{:.8f}", dbl) << std::endl;
              std::cout << std::format("{:.4e}", dbl) << std::endl;
              std::cout << std::format("{:.2f}", dbl) << std::endl;
              
              // C++23: print and println instead of std::cout and std::endl
              std::string firstname = "Donald";
              std::string lastname = "Knuth";
              int answerToEverything = 42;
              
              std::println("Hello, {} {}!", firstname, lastname);
              std::print("The answer is = {}\n", answerToEverything);
            </code></pre>
          <br>
          <p><a href="https://en.cppreference.com/w/cpp/io/print.html">üìö std::print (cppreference)</a></p>

        </section>

      </section>

      <!----------          R√©f√©rences          ---------->
      <section>

        <section>
          <h2>1.4 Passage par r√©f√©rence</h2>
          <p>Une r√©f√©rence √† une variable de type <inline-code>T</inline-code> est de type <inline-code>T&</inline-code>
          </p>
          <br>
          <p>
            <highlight>Une r√©f√©rence est constante</highlight> : elle ne peut √™tre modifi√©e qu'√† sa d√©claration
          </p>

          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">

            int i;
            int &r = i; // r is a reference to i
            r = j; // affects j to i

          </code></pre>
          <br>
          <p>Alternative aux pointeurs</p>
          <p>Surtout utilis√©es pour les passages de param√®tres</p>
          <p>
            <warning>‚ö†Ô∏è Attention : </warning>on ne dispose pas de l'arithm√©tique des pointeurs !
          </p>

          <p>
            <warning>‚ö†Ô∏è Attention : </warning>la signification des op√©rateurs <inline-code>*</inline-code> et
            <inline-code>&</inline-code> d√©pend du contexte !
          </p>
          <br>
          <p><a href="https://en.cppreference.com/w/cpp/language/reference">üìö La d√©claration de r√©f√©rences en C++</a>
          </p>
        </section>

        <section>
          <h2>1.4 Modes de passage des param√®tres</h2>
          <h3>Par valeur</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">
            
            void fn(int param_formel){...}
            fn(param_effectif);
          
          </code></pre>

          <h3>Par adresse</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">

            void fn(int <b>*</b>param_formel){...}
            fn(<b>&</b>param_effectif);
          
          </code></pre>

          <h3>Par r√©f√©rence</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">

            void fn(int <b>&</b>param_formel){...}
            fn(param_effectif);
          
          </code></pre>
          <h3>Par r√©f√©rence sur une constante</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">

            void fn(<b>const</b> int <b>&</b>param_formel){...}
            fn(param_effectif);
          </code></pre>
        </section>

        <section>
          <h2>1.4 Passage par r√©f√©rence II</h2>
          <p>Passer des param√®tres modifiables aux fonctions, sans utiliser les pointeurs</p>
          <br>
          <h3>D√©claration et d√©finition</h3>
          <pre style="width: 1400px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.6em;"
          data-line-numbers="">

          void swap(int &a, int &b)
          {
            int t = a;
            a = b;
            b = t;
          }
        </code></pre>
          <br>
          <h3>Appel</h3>
          <pre style="width: 1400px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.6em;"
          data-line-numbers="">

          int x=2, y=3;
          swap(x, y);
        </code></pre>
        </section>

        <section>
          <h2>1.4 R√©f√©rences sur des donn√©es constantes</h2>
          <p>L'argument <inline-code>pasTouche</inline-code> est n√©cessaire mais ne doit pas √™tre modifi√©</p>
          <br>
          <h3>Passage par valeur</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">

            double CalculerTout(monType pasTouche)
            {
              ...
            }
          
          </code></pre>
          <p></p>

          <p>
            <error>‚õî cr√©ation d'une copie du l'argument</error>
          </p>
          <br>

          <h3>Passage par r√©f√©rence constante</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.2em;"
            data-line-numbers="">

            double CalculerTout(const monType &maRef)
            {
              ...
            }

          </code></pre>

          <p>
            <success>‚úÖ L'argument n'est pas copi√©, et ne peut pas √™tre modifi√©</success>
          </p>

        </section>

        <section>
          <h2>1.4 R√©f√©rences</h2>
          <p>
            <warning>‚ö†Ô∏è Attention √† l'op√©rateur <inline-code>&</inline-code></warning>
          </p>
          <p>3 significations diff√©rentes selon le contexte</p>
          <br>
          <pre style="width: 1400px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 3em;"
          data-line-numbers="">

          int &r = i; // ?

          p = &i; // ?
          
          z = a&b; // ?
        </code></pre>
        </section>

        <section>
          <h2>üå∂Ô∏è 1.4 Fonction renvoyant une r√©f√©rence</h2>
          <h3>Exemple</h3>
          <!-- TODO: maybe post-increment first line, then show that static local variable has been changed? -->
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.6em;"
            data-line-numbers="">

            int& getRefOnCount()
            {
              static int count = 0;
              return count;
            }

            int main()
            {
              std::cout << "Count: " << getRefOnCount()++  << std::endl;
              std::cout << "Count: " << ++getRefOnCount() << std::endl;
            }
          </code></pre>
          <br>
          <h3>Affichage</h3>
          <pre style="width: 1400px;"><code
          class="shell"
          data-trim
          data-noescape
          style="font-size: 2em;">

          Count: 0
          Count: 2
        </code></pre>
        </section>

        <section>
          <h2>üå∂Ô∏è 1.4 Fonction renvoyant une r√©f√©rence</h2>
          <h3>Manipulation au travers d'une fonction-s√©curit√©</h3>
          <div class="container">
            <div class="col-left">
              <pre style="width: 1200px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.4em;"
              data-line-numbers="">
    
              #include &#60;iostream&#62;
              #include &#60;string&#62;
    
              const int N=2;
              std::string tabNoms[N] = {"Bob", "John"};
              int tabAges[N] = {20, 30};
    
              int& age(string nom)
              {
                for (int i = 0; i < N; ++i)
                {
                  if (nom == tabNoms[i])
                  {
                    return tabAges[i];
                  }
                }
                
                // If we are here, the name was not found
                // See chapter on exceptions for more details
                throw std::out_of_range("nom not found");
              } 

            </code></pre>
            </div>
            <div class="col-right">
              <pre style="width: 600px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.6em;"
              data-line-numbers="">
   
              ...
    
              int main()
              {
                age("Bob") = 50;
                age("John")++;

                return 0;
              }
            </code></pre>
            </div>
          </div>
        </section>

      </section>

      <!----------          Valeurs par d√©faut des param√®tres          ---------->
      <section>

        <section>
          <h2>1.5 Valeur par d√©faut des param√®tres</h2>
          <p>Les valeurs sont pr√©cis√©es √† la d√©claration et non √† la d√©finition</p>
          <p>Les param√®tres peuvent √™tre omis √† l'appel</p>
          <pre style="width: 1400px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.6em;"
          data-line-numbers="">
          
          void trier(void *tab, int nbr, int size=100, bool up=true);
        </code></pre>
          <br>
          <p>Appels possibles</p>
          <pre style="width: 1400px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.6em;"
          data-line-numbers="">
          
          trier(tab, nb, 4); // => size=4, up=true
          trier(tab,nb); // => size=100, up=true
          </code></pre>
          <br>
          <p>
            <warning>‚ö†Ô∏è Attention : </warning>les param√®tres par d√©faut doivent √™tre √† la fin de la liste
          </p>
          <br>
          <p><a href="https://en.cppreference.com/w/cpp/language/default_arguments">üìö Param√®tres par d√©faut (cppreference)</a></p>
        </section>

      </section>

      <!----------          1.6 Surcharge des fonctions          ---------->
      <section>

        <section>
          <h2>1.6 Surcharge des fonctions</h2>
          <p>
            <highlight>Signature</highlight> d'une fonction : liste des types des param√®tres d'une fonction
          </p>
          <p>
            <highlight>Surcharge</highlight> d'une fonction : √©criture de plusieurs fonctions de m√™me nom, mais de
            signature diff√©rente
          </p>
          <br>
          <h3>Exemple</h3>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.8em;"
                data-line-numbers="">
                
                int minimum(int a, int b)
                { 
                  return a < b ? a : b;
                } 
                
                int minimum(int a, int b, int c)
                {
                  return minimum(a, minimum(b, c));
                }
              </code></pre>
        </section>
      </section>


      <!----------          1.7 Allocation dynamique          ---------->
      <section>

        <section>
          <h2>1.7 Allocation dynamique de m√©moire</h2>

          <p>
            <inline-code><highlight>new</highlight></inline-code> : est suivi d'un type et r√©serve de la m√©moire pour ce type et renvoie un
            pointeur (ou une exception)
          </p>
          <div style="display: flex; justify-content: center; font-size: 1.4em;">
            <p><inline-code><highlight>new T ‚â° malloc(sizeof(T))</highlight></inline-code></p>
          </div>
          <br>
          <p>
            <highlight>delete</highlight> : est suivi d'une variable contenant une adresse et il lib√®re cette m√©moire
          </p>
          <br>
          <h3>Exemple</h3>
          <pre style="width: 1400px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">

          double *ptr = nullptr;
          ptr = new double; // R√©servation de m√©moire
          delete ptr;       // Lib√©ration de m√©moire
          ptr = nullptr;    // S√©curit√©
        </code></pre>
        </section>

        <section>
          <h2>1.7 Allocation dynamique de tableaux</h2>
          <h3>Exemple</h3>
          <pre style="width: 1400px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">
          int *pTableau = nullptr;
          pTableau = new int[10]; 
          delete [] pTableau;
          pTableau = nullptr;
        </code></pre>
          <br>
          <p><inline-code>new int[10]</inline-code> alloue de la place pour 10 entiers (40 bytes)</p>
          <p>
            <warning>‚ö†Ô∏è Attention :</warning> ne pas oublier <inline-code>[]</inline-code>. Sinon, seul le 1er √©l√©ment est lib√©r√© ‚áí fuite m√©moire
          </p>
          <p>
            <warning>GCC warning</warning><br>
            <inline-code>'void operator delete(void*, std::size_t)' called on pointer returned from a mismatched allocation function [-Wmismatched-new-delete]</inline-code>
          </p>

        </section>

        <section>
          <h2>1.7 Allocation dynamique : gestion d'erreurs</h2>
          <p>En cas d'√©chec d'allocation, <inline-code>new</inline-code> l√®ve une exception
            <inline-code>std::bad_alloc</inline-code></p>
          <br>
          <h3>Exemple</h3>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            // See chapter on exceptions for more details
            try
            {
              // throws std::bad_alloc if no more memory is available
              x = new int[1024 * 1024];
            }
            // See chapter on exceptions for more details
            catch (const std::bad_alloc &e)
            {
              std::cout << "Memory allocation failed." << std::endl;
            }
          </code></pre>
          <p><a href="https://en.cppreference.com/w/cpp/memory/new/operator_new">üìö new (cppreference)</a></p>
        </section>
        
        <section>
          <h2>1.7 Allocation dynamique : gestion d'erreurs</h2>
          <p>
            <error>‚õî √âviter d'utiliser cette version quand on utilise les exceptions pour g√©rer les erreurs</error>
          </p>
          <p><inline-code>new(std::nothrow)</inline-code> se contente de renvoyer <inline-code>nullptr</inline-code> en cas
            d'√©chec.</p>
          <br>
          <h3>Exemple</h3>
          <pre style="width: 1400px;"><code
                  class="c++"
                  data-trim
                  data-noescape
                  style="font-size: 1.8em;"
                  data-line-numbers="">
                  int *ptr = new (std::nothrow) int[1024];
                  if(ptr == nullptr)
                  {
                    ...
                  }
                </code></pre>
          <p><a href="https://en.cppreference.com/w/cpp/memory/new/operator_new">üìö new (cppreference)</a></p>
        </section>
        
        </section>
      <!----------          1.8 La classe std::string          ---------->
      <section>
      
        <section>
          <h2>1.8 La classe <span style="text-transform: lowercase;"><inline-code>std::string</inline-code></span></h2>
          <p>Type (classe) pour les cha√Ænes en C++ : <inline-code>std::string</inline-code></p>
          <p>Plus simple et plus s√ªr que <inline-code>char*</inline-code></p>
          <p>Gestion automatique/dynamique de la taille</p>
          <p>Op√©rateurs et fonctions d√©di√©es</p>
      
          <p><inline-code>std::string</inline-code> est d√©clar√© dans <inline-code>&#60;string&#62;</inline-code> et visible dans <inline-code>std</inline-code></p>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.8em;"
                data-line-numbers="">
                #include &#60;string&#62;
                
                int main()
                {
                  std::string x = "toto";
                  std::string y("toto");
                }
              </code></pre>
      
        </section>

        <section>
          <h2>1.8 La classe <span style="text-transform: lowercase;"><inline-code>std::string</inline-code></span></h2>
          <b>
            <p>Op√©rateurs</p>
          </b>
          <div style="font-size: 0.8em;">
            <p>Affectation : <inline-code>=</inline-code></p>
            <p>Concat√©nation : <inline-code>+</inline-code>, <inline-code>+=</inline-code></p>
            <p>Comparaisons : <inline-code>==</inline-code>, <inline-code>&lt;</inline-code>, <inline-code>&gt;</inline-code>,
              <inline-code>&lt;=</inline-code>, <inline-code>&gt;=</inline-code></p>
          </div>
          <b>
            <p>M√©thodes</p>
          </b>
          <div style="font-size: 0.8em;">
            <p><inline-code>int size()</inline-code> : renvoie le nombre de caract√®res</p>
            <p><inline-code>int length()</inline-code> : renvoie le nombre de caract√®res</p>
            <p><inline-code>int capacity()</inline-code> : taille possible sans r√©allocation</p>
            <p><inline-code>bool empty()</inline-code> : vrai si la cha√Æne est vide, faux sinon</p>
            <p><inline-code>int find(string s, int pos)</inline-code> : position de la chaine <inline-code>s</inline-code> dans la chaine courante √† partir de <inline-code>pos</inline-code></p>
            <p><inline-code>string substr(int start, int length)</inline-code> : sous-chaine de longueur <inline-code>length</inline-code> √† partir de <inline-code>start</inline-code></p>
          </div>
          <br>
          <p><a href="https://en.cppreference.com/w/cpp/string">üìö std::string (cppreference)</a></p>
        </section>

        <section>
          <h2>1.8 La classe <span style="text-transform: lowercase;"><inline-code>std::string</inline-code></span></h2>
          <b><p>Exemple</p></b>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.6em;"
                data-line-numbers="">
                #include &#60;iostream&#62;
                #include &#60;string&#62;
                
                int main()
                {
                  std::string x = "toto";
                  std::string y = x;
                  std::string z = x + "_" + y;
                  std::cout << x << " " << y << " " << z << std::endl;
                  std::cout << "cap: " << z.capacity() << std::endl; 
                  std::cout << "size: " << z.size()     << std::endl;
                  return 0;
                }
              </code></pre>
              <b><p>Affichage</p></b>
              <pre style="width: 1400px;"><code
                class="shell"
                data-trim
                data-noescape
                style="font-size: 1.8em;">
                toto toto toto_toto
                cap: 15
                size: 9
              </code></pre>
        </section>

        <section>
          <h2>1.8 Conversion de <span style="text-transform: lowercase;"><inline-code>std::string</inline-code></span> (sans flux)</h2>
          <p>Conversion de <inline-code>const char*</inline-code> vers <inline-code>std::string</inline-code></p>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                const char *ptr2char = "Hello";
                std::string mystring(ptr2char);
              </code></pre>
              <p><warning>‚ö†Ô∏è Attention :</warning> on passe d'un tableau de caract√®res (pointeur) √† un objet (structure)</p>
              <br>
          <p>Conversion de <inline-code>std::string</inline-code> vers <inline-code>const char*</inline-code></p>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                std::string mystring = "Hello";
                const char *ptr2char2 = nullptr;
                ptr2char2 = mystring.c_str();
              </code></pre>
              <p><warning>‚ö†Ô∏è Attention :</warning> on passe d'un object (structure) √† un tableau de caract√®res (pointeur)</p>
        </section>

        <section>
          <h2>1.8 Le flux <span style="text-transform: lowercase;"><inline-code>std::string</inline-code></span></h2>
          <p>Les flux permettent de convertir des donn√©es en cha√Ænes de caract√®res</p>
          <p>La source ou la destination d'un flux peut √™tre une cha√Æne de caract√®res</p>
          <p>‚áí Les 2 sont constitu√©s d'octets</p>
          <p>Int√©r√™ts : conversions, transferts en m√©moire (buffers)</p>
          <br>          
          <p><inline-code>#include &#60;sstream&#62</inline-code> ‚áí 3 classes</p>
          <br>
          <p><inline-code>istringstream</inline-code> : entr√©e</p>
          <p><inline-code>ostringstream</inline-code> : sortie</p>
          <p><inline-code>stringstream</inline-code> : les deux</p>
          <br>
          <p><a href="https://en.cppreference.com/w/cpp/io/basic_stringstream">üìö std::stringstream (cppreference)</a></p>
        </section>

        <section>
          <h2>1.8 Conversion de <span style="text-transform: lowercase;"><inline-code>std::string</inline-code></span> (avec flux)</h2>

          <p>Conversion de <inline-code>int</inline-code> vers <inline-code>std::string</inline-code></p>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.8em;"
                data-line-numbers="">
                #include &#60;sstream&#62;
                int main()	
                {		
                  std::ostringstream toto;
                  toto << 10;
                  std::string texte = toto.str();
                }
              </code></pre>
          <p>Conversion de <inline-code>std::string</inline-code> vers <inline-code>int</inline-code></p>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.8em;"
                data-line-numbers="">
                #include &#60;sstream&#62;
                int main()	
                {		
                  std::istringstream titi("10");
                  int nombre;
                  titi >> nombre;
                }
              </code></pre> 
        </section>
        
      </section>

      <!----------          1.9 Divers : inf√©rences de type, range-for, etc.          ---------->
      <section>

        <section>
          <h2>1.9 Les fonctions <span style="text-transform: lowercase;"><inline-code>inline</inline-code></span></h2>
          <p>Fonctions dont le code est copi√© √† chaque appel</p>
          <p>Utilis√©es pour des fonctions courtes et fr√©quemment appel√©es</p>
          <p><b>Macro en C</b></p>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.8em;"
                data-line-numbers="">
                #define MAX(x,y) ((x)>(y)?(x):(y))
              </code></pre>
          <b><p><inline-code>inline</inline-code> en C++</p></b>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.8em;"
                data-line-numbers="">
                inline int max(int x, int y) { return x>y ? x : y; }
              </code></pre>
              <br>
          <p>Les expressions <inline-code>x=MAX(2,b+1);</inline-code> et <inline-code>x=max(2,b+1);</inline-code> sont remplac√©es par le compilateur par <inline-code>x=((2)>(b+1)?(2):(b+1));</inline-code></p>
        </section>

        <section>
          <h2>1.9 Les <span style="text-transform: lowercase;"><inline-code>struct</inline-code></span> en C++</h2>
          <p>En C++, une structure peut aussi contenir des fonctions (m√©thodes)</p>
          <b><p>Exemple</p></b>
          <pre style="width: 1400px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.8em;"
                data-line-numbers="">
                struct Vecteur
                {
                  double x, y;
                  double longueur()
                  {
                    return (sqrt(x*x + y*y));
                  }
                };
                Vecteur v;
                v.x=3.0; v.y=4.0;
                v.longueur();
              </code></pre>
              <br>
              <p>üìå Pas besoin de mentionner <inline-code>struct</inline-code></p>
        </section>

        <section>
          <h2>1.9 divers</h2>
          <p>Utiliser <inline-code>nullptr</inline-code>, et non <inline-code>0</inline-code> ou <inline-code>NULL</inline-code></p>
          <p>Terminer les fichiers source par une ligne vide pour des raisons de compatibilit√© avec certains anciens outils qui peuvent ignorer une ligne se terminant par EOF </p>
          <p>Utiliser <inline-code>auto</inline-code> pour l'inf√©rence de type</p>
          <p>Utiliser <inline-code>decltype</inline-code> pour obtenir le type d'une expression</p>
          <p>‚áí Tr√®s utile pour les it√©rateurs et le templates</p> 
        </section>

        <section>
          <h2>1.9 Range-based for loop</h2>
          <pre style="width: 1400px;">
            <code class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 1.8em;"
                        data-line-numbers="">
                        int values[] = {10, 20, 26};

                        for (const auto& value : values) 
                        { 
                          cout << value << endl; 
                        }
                      </code></pre>
                      <br>

          <b><p>Affichage</p></b>
          <pre style="width: 1400px;"><code
                        class="shell"
                        data-trim
                        data-noescape
                        style="font-size: 1.8em;">
                        10
                        20
                        26
                      </code></pre>
          <br>
          <p><a href="https://en.cppreference.com/w/cpp/language/range-for">üìö Range-based for loop (cppreference)</a></p>
        </section>

      </section>

      <!----------          1.10 Bilbioth√®que standard          ---------->
      <section>

        <section>
          <h2>1.10 Biblioth√®que standard</h2>
          <p><warning>‚ö†Ô∏è Plus de d√©tails au chapitre 9 : biblioth√®que standard</warning></p>
          <p>Structures de donn√©es classiques (avec les algorithmes associ√©s)</p>
          <p>Int√©gr√©e √† la proc√©dure de standardisation de C++</p>
          <p>Bas√©e sur les mod√®les de classes (conteneurs valables pour plusieurs classes/types diff√©rents)</p>
          <br>
          <b><p>Contient</p></b>
          <ul>
            <li>Conteneurs : impl√©mentation de structures de donn√©es classiques (Chapitre 9)</li>
            <li>It√©rateurs : offrent des m√©thodes unifi√©es d'acc√®s aux conteneurs (Chapitre 9)</li>
            <li>Algorithmes : offrent des algorithmes pour les conteneurs (Chapitre 9)</li>
            <li>Foncteur : objets fonctions (non trait√©s dans ce cours)</li>
          </ul>
          <br>
          <br>
          <p><a href="https://en.cppreference.com/w/cpp/header">üìö Biblioth√®que standard (cppreference)</a></p>
        </section>

        <section>
          <h2>1.10 Conteneurs et it√©rateurs</h2>
          <b><p>Conteneurs</p></b>
          <p>Objets permettant de stocker d'autres objets</p>
          <p>Permettent de g√©rer les objets contenus : ajout, suppression, insertion</p>
          <br>
          <b><p>It√©rateurs</p></b>
          <p>Permettent de parcourir une collection d'objets sans avoir √† se pr√©occuper de l'impl√©mentation. Ceci permet d'avoir une interface de manipulation commune</p>
          <p>Utilisation possible d'algorithmes comme tri, recherche, remplacement</p>
        </section>

        <section>
          <h2>1.10 Les conteneurs</h2>

          <p>2 types de conteneurs : <highlight>s√©quentiels</highlight> et <highlight>associatifs</highlight></p>
          <br>
          <b><p>Les conteneurs s√©quentiels</p></b>
          <p>Conteneurs dont les √©l√©ments sont ordonn√©s</p>
          <p>On peut parcourir le conteneur suivant cet ordre et ins√©rer ou supprimer un √©l√©ment en un endroit explicitement choisi</p>
          <p>Exemples : vecteurs, listes, piles, files, ...</p>
          <br>
          <b><p>Les conteneurs associatifs</p></b>
          <p>Conteneurs dont les √©l√©ments sont identifi√©s par une cl√© et ordonn√©s suivant celle-ci</p>
          <p>Pour ins√©rer un √©l√©ment, il n'est en th√©orie plus utile de pr√©ciser un emplacement</p>
          <p>Exemples : dictionnaires, ensembles</p>
        </section>

        <section>
          <h2>1.10 Les classes conteneurs</h2>
          <img data-src="./medias/classes_conteneurs.png" width="1350px" />
        </section>

        <section>
          <h2>1.10 Les classes conteneurs</h2>
          <h3><span style="text-transform: lowercase;"><inline-code>#include <...></inline-code></span></h3>
          <br>
          <div class="container">
            <div class="col-left">
              <b><p>Conteneurs s√©quentiels</p></b>
              <p>Tableau dynamique contigu : <inline-code>vector</inline-code></p>
              <p>Tableau statique contigu : <inline-code>array</inline-code></p>
              <p>File √† double entr√©e : <inline-code>deque</inline-code></p>
              <p>Liste doublement chain√©e : <inline-code>list</inline-code></p>
              <p>Liste simplement chain√©e : <inline-code>forward_list</inline-code></p>
            </div>
            <div class="col-right">
              <b><p>Conteneurs associatifs</p></b>
              <p>Dictionnaires (cl√© ‚ü∑ valeur) : <inline-code>map</inline-code>, <inline-code>multi_map</inline-code></p>
              <p>Ensembles : <inline-code>set</inline-code>, <inline-code>multi_set</inline-code></p>
              <br>
              <b><p>Conteneurs d√©riv√©s</p></b>
              <p>Files : <inline-code>queue</inline-code>, <inline-code>priority_queue</inline-code></p>
              <p>Piles : <inline-code>stack</inline-code></p>
            </div>
          </div>  
        </section>

        <section>
          <h2>1.10 M√©thode courantes des conteneur</h2>
          <p><inline-code>clear()</inline-code> : vide le conteneur</p>
          <p><inline-code>size()</inline-code> : retourne le nombre d'√©l√©ments</p>
          <p><inline-code>empty()</inline-code> : teste si le conteneur est vide</p>
          <p><inline-code>push_back(...)</inline-code> : ajoute un √©l√©ment √† la fin</p>
          <p><inline-code>push_front(...)</inline-code> : ajoute un √©l√©ment au d√©but</p>
          <p><inline-code>front()</inline-code> : renvoie le 1er √©l√©ment</p>
          <p><inline-code>pop_front()</inline-code> : supprime le premier √©l√©ment</p>
          <p><inline-code>insert()</inline-code> : ins√®re un √©l√©ment</p>
          <p><inline-code>erase()</inline-code> : supprime un √©l√©ment</p>
          <p><inline-code>sort()</inline-code> : trie le contenu d'une conteneur</p>
          <p><inline-code>find()</inline-code> : recherche dans le conteneur</p>
        </section>

        <section>
          <h2>1.10 Conteneur s√©quentiel : <span style="text-transform: lowercase;"><inline-code>std::vector</inline-code></span>
          </h2>
          <pre style="width: 1400px;"><code
                        class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 2em;"
                        data-line-numbers="">
                        #include &#60;vector&#62;
        
                        int main()
                        {
                          std::vector&#60;int&#62;  myVector1{10,11};
                      
                          std::vector&#60;double&#62; myVector2;
                          myVector2.push_back(11.0);
                          myVector2.push_front(10.0);
                      
                          std::vector&#60;int&#62; myVector3(2,5);
                          myVector3[0]=10;
                          myVector3[1]=11;                 
                          ...                  
                        }
                      </code></pre>
        </section>
        
        <section>
          <h2>1.10 Conteneur s√©quentiel : <span style="text-transform: lowercase;"><inline-code>std::vector</inline-code></span>
          </h2>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.6em;"
            data-line-numbers="">
            for (int item : myVector1)
            {
              std::cout << item << " ";
            }
            
            for (const int& item : myVector1)
            {
              std::cout << item << " ";
            }
            
            for (const auto& item : myVector1)
            {
              std::cout << item << " ";
            }
            
            for (int i = 0; i < (int)myVector1.size(); i++)
            {
                std::cout << myVector1[i] << " (";
                std::cout << myVector1.at(i) << ") ";
            }</code></pre>
        </section>

        <section>
          <h2>1.10 Conteneur s√©quentiel : <span style="text-transform: lowercase;"><inline-code>std::vector</inline-code></span>
          </h2>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            #include &#60;iostream&#62;
            #include &#60;vector&#62;
            #include &#60;algorithm&#62; // std::sort
            
            int main()
            {
              std::vector&#60;int&#62; v{5, -4, 9, 5, 3, 0};

              // Ascending order
              std::sort(v.begin(), v.end());
              
              // Descending order
              std::sort(v.begin(), v.end(), std::greater&#60;int&#62;());

              return 0;
            }</code></pre>
        </section>

        <section>
          <h2>1.10 Conteneur s√©quentiel : <span style="text-transform: lowercase;"><inline-code>std::vector</inline-code></span>
          </h2>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            #include &#60;iostream&#62;
            #include &#60;vector&#62;
            #include &#60;string&#62;

            int main()
            {           
              std::vector&#60;string&#62; v;
              v.push_back("Introduction");
              v.push_back("une phrase");
              v.push_back("Conclusion");
              for(int i = 0; i < vect.size(); ++i)
              {
                std::cout << vect[i] << std::endl;
              }              
              return 0;
            }</code></pre>
        </section>

        <section>
          <h2>1.10 Conteneur s√©quentiel : <span style="text-transform: lowercase;"><inline-code>std::array</inline-code></span></h2>
            <pre style="width: 1400px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 2em;"
              data-line-numbers="">
              #include &#60;array&#62;

              int main()
              {
                std::array&#60;int, 2&#62; myArray1{10,11}; // 10 11
                std::array&#60;int, 2&#62; myArray2{0}; // 0 0

                std::array&#60;int, 2&#62; myArray3;
                // myArray3.push_back(10); => not possible
              
                std::array&#60;int, 2&#62; myArray4;
                myArray4[0] = 10;
                myArray4[1] = 11; // 10 11

                return 0;
              }</code></pre>
        </section>

        <section>
          <h2>1.10 Imbrication de conteneurs</h2>
          <p>Il est possible d'imbriquer les conteneurs</p>
          <p>On peut par exemple, cr√©er un vecteur de listes de cha√Ænes de caract√®res</p>
          <p><inline-code>std::vector&#60;std::list&#60;std::string&#62;&#62; maChanson;</inline-code></p>
          <br>
          <p>La d√©finition d'un type interm√©diaire peut augmenter la lisibilit√©</p>
          <p><inline-code>typedef list&#60;string&#62; Couplet;</inline-code></p>
          <p><inline-code>vector&#60;Couplet&#62; maChanson;</inline-code></p>
        </section>

        <section>
          <h2>1.10 Imbrication de conteneurs</h2>
          <p>Des objets <inline-code>std::vector</inline-code> imbriqu√©s simulent des tableaux multidimensionnels</p>
          <p>On peut initialiser une matrice identit√© M (5x5) avec le code suivant :</p>
          <pre style="width: 1400px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.6em;"
            data-line-numbers="">
            typedef std::vector&#60;float&#62; Line;
            typedef std::vector&#60;Line&#62; Matrix;
            Matrix m(5); 	// 5 lines
            for(int i = 0; i < 5; ++i)
            {
              m[i].resize(5);   // rows size is 5
              for(int j = 0; j < 5; ++j)
              {
                if (i==j)
                {
                  m[i][j]=1;
                }
                else
                {
                  m[i][j]=0; 
                }
              }
            }</code></pre>
        </section>

        <section>
          <h2>Mots-cl√©s en C++</h2>
          <iframe src="https://en.cppreference.com/w/cpp/keyword" width="1600px" height="800px"></iframe>
        </section>

      </section>
    </div>
  </div>

  <!----------          CONTENT          ---------->

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,
      width: 1920,
      height: 1080,
      transition: "none",
      center: false,
      slideNumber: 'c/t',

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>