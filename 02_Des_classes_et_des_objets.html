<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>HE-Arc - 1242.2 Langage C++ - Chapitre 2 - Des classes et des objets</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/hearc.css" id="theme">
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="https://www.he-arc.ch/wp-content/uploads/2021/12/cropped-hearc-icon-192x192.png"
    type="image/vnd.microsoft.icon" />

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/vs.css" id="highlight-theme">
</head>

<body>
  <img id="logo-hearc" src="./medias/logo_he-arc.png" alt="Logo HE-ARC">
  <img id="logo-hesso" src="./medias/logo_hes-so.png" alt="Logo HES-SO">
  <p id="course-infos">1242.2 Langage C++ - 2025-2026</p>

  <div class="reveal">
    <div class="slides">

      <!----------          TITLE          ---------->
      <section>
        <h1>
          Chapitre 2
        </h1>
        <h2>
          Des classes et des objets
        </h2>
        <div class="container">
          <div class="col-left">
            <p>1. Introduction</p>
            <p>2. D√©finition d'une classe</p>
            <p>3. Impl√©mentation d'une m√©thode</p>
            <p>4. Instancier des objets</p>
            <p>5. Les constructeurs</p>
          </div>
          <div class="col-right">
            <p>6. Le destructeur</p>
            <p>7. Membres constants</p>
            <p>8. <inline-code>this</inline-code>, Membres statiques, <inline-code>friend</inline-code></p>
            <p>9. Diagrammes UML</p>
            <p>10. <inline-code>=delete</inline-code> et <inline-code>=default</inline-code></p>
          </div>
        </div>
      </section>

      <!----------          INTRODUCTION          ---------->
      <section>

        <section>
          <h2>2.1 Paradigmes de programmation</h2>
          <b>
            <p>Proc√©durale / imp√©rative</p>
          </b>
          <p>S√©paration des donn√©es et des fonctions</p>
          <p>Une fonction agit sur des donn√©es</p>
          <br>
          <b>
            <p>Orient√©e objet (POO)</p>
          </b>
          <p>Regroupement des fonctions et donn√©es dans un objet</p>
          <p>Envoi de "messages" entre objets</p>

        </section>

        <section>
          <h2>2.1 Principe de la POO</h2>
          <p>
            <highlight>D√©crire les objets et les actions possibles sur ces objets</highlight>
          </p>
          <br>
          <h3>Avantages</h3>
          <p>Approche naturelle</p>
          <p>Code r√©utilisable</p>
          <p>Modulaire</p>
          <p>Plus facile √† maintenir / √† faire √©voluer</p>
          <p>Meilleure gestion pour les gros projets</p>
        </section>

        <section>
          <h2>2.1 Notion de classe</h2>

          <div class="container">
            <div class="col-left">
              <h3>C</h3>
              <pre style="width: 800px;"><code
                        class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 1.6em;"
                        data-line-numbers="">

                        int balance = 0;
          
                        void deposit(int x)
                        {
                          balance += x;
                        }
          
                        int main(void)
                        {
                          deposit(15);
          
                          return 0;
                        }</code></pre>
            </div>
            <div class="col-right">
              <h3>C++</h3>
              <pre style="width: 800px;"><code
                        class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 1.6em;"
                        data-line-numbers="">
          
                        class Account
                        {
                          int balance{0};
          
                          void deposit(int x)
                          {
                            balance += x;
                          }
                        };
          
                        int main()
                        {
                          Account myAccount;
                          Account otherAccount;
          
                          myAccount.deposit(15);
          
                          return 0;
                        }</code></pre>
            </div>
          </div>
        </section>

        <section>
          <h2>2.1 Classe vs Objet</h2>

          <p>Une classe est un <highlight>type</highlight> d√©fini par le programmeur</p>
          <img src="./medias/ClasseVoiture.png" alt="Classe" width="600px">

          <p>Un objet est une <highlight>instance</highlight> de cette classe</p>
          <img src="./medias/ObjetsVoitures.png" alt="Objet" width="1600px">
        </section>

        <section>
          <h2>2.1 Principes de POO</h2>
          <p><b>Une classe est la description abstraite d'un objet. Elle regroupe des <highlight>attributs</highlight>
              et des <highlight>m√©thodes</highlight></b></p>
          <br>
          <h3>Attributs</h3>
          <p>Appel√©s aussi des variables membres (de la classe)</p>
          <p>D√©crivent l'√©tat de l'objet</p>
          <p>Exemples : vitesse, poids, nombre de passagers, etc.</p>
          <br>
          <h3>M√©thodes</h3>
          <p>Appel√©es aussi des fonctions membres (de la classe)</p>
          <p>D√©crivent les actions qu'un objet peut effectuer</p>
          <p>Exemples : d√©marrer, acc√©l√©rer, freiner, etc.</p>
        </section>

        <section>
          <h2>2.1 Exemple de classe</h2>
          <p>D√©finition de la classe <inline-code>Point</inline-code></p>
          <pre style="width: 1400px;"><code
                        class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 1.6em;"
                        data-line-numbers="">
                        
                        #include &#60;print&#62;
                        
                        // Class name: Point
                        class Point
                        {
                          public:

                            // Methods
                            void init(int, int);
                            void translate(int, int);
                            void print()
                            {
                              std::println("({},{})", x, y);
                            }
                            
                            // Attributes
                            int x{0};
                            int y{0};
                          };
                        
                        </code></pre>

        </section>

        <section>
          <h2>2.1 Exemple de classe</h2>
          <p>D√©finition <highlight>des m√©thodes </highlight>de la classe <inline-code>Point</inline-code></p>
          <pre style="width: 1400px;"><code
                        class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 1.6em;"
                        data-line-numbers="">
                        
                        ...
                        
                        void Point::init(int _x, int _y)
                        {
                          x=_x;
                          y=_y;
                        }
                        
                        void Point::translate(int delta_x, int delta_y)
                        {
                          x += delta_x;
                          y += delta_y;
                        }
                        
                        ...

                      
                      
                      </code></pre>
        </section>

        <section>
          <h2>2.1 Exemple de classe</h2>
          <p>Utilisation <highlight>des objets </highlight>de la classe <inline-code>Point</inline-code></p>
          <pre style="width: 1400px;"><code
                        class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 1.6em;"
                        data-line-numbers="">
                        
                        int main()
                        {
                          // Point is a class
                          // p1 is an object of the class Point
                          Point p1;
                          
                          p1.init(-1,2);
                          
                          p1.print();
                          p1.translate(10,10);
                          p1.print();
                          
                          return 0;
                        }
                      
                      </code></pre>
        </section>

        <section>
          <h2>2.1 Caract√©ristiques d'un objet</h2>
          <b>
            <p>Un objet poss√®de un <highlight>√©tat interne</highlight>
            </p>
          </b>
          <p>C'est l'ensemble des valeurs qui d√©crit l'√©tat de l'objet √† un instant donn√©.
            Cet √©tat n'est pas directement accessible : l'utilisateur doit y acc√©der au travers de son interface.</p>

          <b>
            <p>Un objet poss√®de une <highlight>impl√©mentation</highlight>
            </p>
          </b>
          <p>C'est la fa√ßon dont l'objet est r√©alis√©.
            L'impl√©mentation n'est pas accessible √† l'utilisateur.
            2 classes ayant la m√™me interface peuvent avoir une impl√©mentation diff√©rente.</p>

          <p>
            <highlight>Un objet appartient √† une classe</highlight>
          </p>
          <p>La classe est le "moule" √† partir duquel on cr√©e un objet.
            Un objet en est une instanciation.</p>

          <p>
            <highlight>Un objet est identifiable (nommable)</highlight>
          </p>
          <p>On peut distinguer les objets entre eux en les nommant, m√™me s'ils sont de la m√™me classe.</p>
        </section>

      </section>

      <!----------          D√âCLARATION D'UNE CLASSE ET DE SES ATTRIBUTS          ---------->
      <section>

        <section>
          <h2>2.2 D√©claration d'une classe en C++</h2>
          <h3>Syntaxe</h3>

          <pre style="width: 1400px;"><code
                        class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 2.7em;"
                        data-line-numbers="">
                        
                        <b>class NomDeLaClasse</b>
                        {
                          <b>public:</b>
                            int uneFonctionMembre();
                            double unAttribut;

                          <b>private:</b>
                            char unAutreAttribut;
                        }<b>;</b> // ‚ö†Ô∏è Do not forget the semicolon
                        
                        </code></pre>
        </section>

        <section>
          <h2>2.2 D√©claration d'une classe en C++</h2>
          <h3>Contr√¥le d'acc√®s aux membres</h3>
          <p><inline-code>public</inline-code> : les membres sont accessibles par tous</p>
          <p><inline-code>private</inline-code> : les membres sont accessibles uniquement par les m√©thodes de la classe.
            C'est le mode par d√©faut.</p>

          <div class="container">
            <div class="col-left">
              <pre style="width: 700px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                
                class XYZ
                {
                  public:
                    void fctPub(){..}
                    int varPub;

                  private:
                    void fctPriv(){..}
                    int varPriv;
                };                
                
                </code></pre>

            </div>
            <div class="col-right">
              <pre style="width: 700px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                
                int main()
                {
                  <b>XYZ</b> x;
                
                  x.fctPub(); // ‚úÖ
                  x.varPub=3; // ‚úÖ

                  <b>x.fctPriv();</b> // ‚õî
                  <b>x.varPriv=6;</b> // ‚õî
                }
                                
                </code></pre>
            </div>
          </div>
        </section>

        <section>
          <h2>2.2 D√©claration d'une classe en C++</h2>
          <h3>Contr√¥le d'acc√®s aux membres</h3>
          <p><inline-code>public</inline-code> : les membres sont accessibles par tous</p>
          <p><inline-code>private</inline-code> : les membres sont accessibles uniquement par les m√©thodes de la classe.
            C'est le mode par d√©faut.</p>

          <div class="container">
            <div class="col-left">
              <pre style="width: 700px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                
                class XYZ
                {
                  public:
                    void fctPub(){..}
                    int varPub;

                  private:
                    void fctPriv(){..}
                    int varPriv;
                };                
                
                </code></pre>

            </div>
            <div class="col-right">
              <pre style="width: 700px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">                

                void <b>XYZ</b>::fctPub()
                { 
                  varPub = 3;  // ‚úÖ
                  varPriv = 6; // ‚úÖ
                }
                void <b>XYZ</b>::fctPriv()
                { 
                  varPub = 3;  // ‚úÖ
                  varPriv = 6; // ‚úÖ
                }                
                                                
                </code></pre>
            </div>
          </div>
        </section>

        <section>
          <h2>2.2 Encapsulation</h2>
          <b>
            <p>L'impl√©mentation et le type des donn√©es sont cach√©s (peuvent √©voluer)</p>
          </b>
          <p>‚áí Permet <highlight>l'√©volutivit√© des programmes</highlight>
          </p>
          <br>
          <b>
            <p>La visibilit√© des membres est g√©r√©e avec <inline-code>public</inline-code>,
              <inline-code>private</inline-code> et <inline-code>protected</inline-code>
            </p>
          </b>
          <b>
            <p>L'acc√®s aux membres est g√©r√© par des <highlight>accesseurs</highlight>
              (<inline-code>getX()</inline-code>) et des <highlight>modificateurs</highlight>
              (<inline-code>setX()</inline-code>)</p>
          </b>
          <p>‚áí Garantit la coh√©rence/s√©curit√© des donn√©es </p>
        </section>

        <section>
          <h2>2.2 Encapsulation</h2>
          <p>Les fonctions sont <inline-code>public</inline-code>, et les donn√©es sont
            <inline-code>private</inline-code> (ou <inline-code>protected</inline-code>)
          </p>

          <div class="container">
            <div class="col-left">
              <pre style="width: 700px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.7em;"
                data-line-numbers="">
                
                class Account
                {
                  <b>public:</b>
                    void deposit(int x)
                    {
                      balance += x;
                    }
                    void withdraw(int x)
                    {
                      balance -= x;
                    }
                    int getBalance()
                    {
                      return balance;
                    }

                  <b>private:</b>
                    int balance{0};
                };                
                </code></pre>

            </div>
            <div class="col-right">
              <pre style="width: 1000px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.7em;"
                data-line-numbers="">                

                int main()
                {
                  Account myAccount;
                  myAccount.deposit(100);
                  myAccount.withdraw(50);
                  auto balance = myAccount.getBalance();
                  std::println("Balance: {}", balance);

                  myAccount.balance = 1000; // ‚õî
                  std::println("Balance: {}", myAccount.balance); // ‚õî

                  return 0;
                }
                                                
                </code></pre>
            </div>
          </div>
        </section>

        <section>
          <h2>2.2 Port√©e des attributs et des m√©thodes</h2>
          <b>
            <p>Certaines m√©thodes doivent √™tre publiques</p>
          </b>
          <p>les constructeurs (en g√©n√©ral)</p>
          <p>les accesseurs, les modificateurs</p>
          <br>
          <b>
            <p>On recommande de</p>
          </b>
          <p>d√©clarer les attributs priv√©s</p>
          <p>les rendre accessibles par des m√©thodes publiques (accesseurs et modificateurs).</p>

          <p><b>üìå Note :</b> un membre d√©clar√© sans modificateur d'acc√®s sera <inline-code>private</inline-code> par
            d√©faut (accessible uniquement depuis les m√©thodes de la classe)</p>

        </section>

      </section>

      <!----------          D√âFINITION D'UNE METHODE          ---------->
      <section>

        <section>
          <h2>2.3 D√©finition des m√©thodes</h2>
          <h3>En-ligne</h3>
          <p>Dans la d√©claration de la classe</p>
          <p>Mot-clef inline (implicite)</p>
          <p>Pour des fonctions courtes</p>
          <br>
          <h3>S√©par√©e</h3>
          <p>Prototype dans d√©claration de la classe</p>
          <p>D√©finition hors de la d√©claration de la classe</p>
          <p>Op√©rateur de port√©e <inline-code>::</inline-code></p>
        </section>

        <section>
          <h2>2.3 D√©finition des m√©thodes</h2>
          <h3>En-ligne</h3>

          <pre style="width: 1600px;"><code
                        class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 2em;"
                        data-line-numbers="">
                        
                        class Point 
                        {
                          public:
                            int getX()
                            {
                              return x;
                            }
                            <b>inline</b> void setX(int _x) // üìå inline is optional here
                            {
                              x = _x;
                            }

                          private:
                            int x{0}, y{0};
                        };
                        
                        </code></pre>

        </section>

        <section>
          <h2>2.3 D√©finition des m√©thodes</h2>
          <h3>S√©par√©e</h3>

          <pre style="width: 1600px;"><code
                        class="c++"
                        data-trim
                        data-noescape
                        style="font-size: 2em;"
                        data-line-numbers="">
                        
                        // Class declaration
                        class Point
                        {
                          public:
                            void display();

                          private:
                            int x{0}, y{0};
                        };
                        
                        // Point::display() definition
                        <b>inline</b> void Point::display() // üìå inline mandatory
                        {
                          std::println("({},{})", x, y);
                        }
                                                
                        </code></pre>
        </section>

        <section>
          <h2>2.3 D√©finitions de m√©thodes</h2>
          <h3>Organisation d'un projet C++</h3>
          <p>2 fichiers par classe : <inline-code>classe.h</inline-code> (d√©clarations classe et membres) +
            <inline-code>classe.cpp</inline-code> (d√©finitions m√©thodes)
          </p>
          <p>Directives de non-inclusion multiple dans les interfaces</p>

          <div class="container">
            <div class="col-left">
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.6em;"
                data-line-numbers="">

                // Classe.h
                #ifndef CLASSE_H
                #define CLASSE_H
                ...
                #endif
              </code></pre>
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.6em;"
                data-line-numbers="">

                // Classe.cpp
                #include "classe.h"
              </code></pre>
            </div>
            <div class="col-right">
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.6em;"
                data-line-numbers="">

                // Classe.h
                <b>#pragma once</b>
                ...
              </code></pre>
              <br>
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.6em;"
                data-line-numbers="">
  
                // Classe.cpp
                #include "classe.h"
              </code></pre>
            </div>
          </div>

          <p>üìå 1 fichier peut contenir plusieurs classes</p>
          <p>‚úÖ 1 seule classe par paire de fichiers <inline-code>.h</inline-code> et <inline-code>.cpp</inline-code>
          </p>
        </section>

        <section>
          <h2>2.3 D√©finitions de m√©thodes</h2>

          <div class="container">
            <div class="col-left">
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.6em;"
                data-line-numbers="">

                // Point.h
                #pragma once

                class Point
                {
                  public:
                    ...

                    <b>int getX(){return x;} // inline</b>
                    void print();
                };
              </code></pre>
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.6em;"
                data-line-numbers="">

                // Point.cpp
                #include "Point.h"
                ...

                void Point::print()
                {
                  std::println("Point: ({},{})", x, y);
                }                
              </code></pre>
            </div>
            <div class="col-right">
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.6em;"
                data-line-numbers="">

                // main.cpp
                #include "Point.h"

                int main()
                {
                  <b>Point ptA;</b>

                  ...

                  return 0;
                }
              </code></pre>
            </div>
          </div>
        </section>

      </section>

      <!----------          INSTANCIER DES OBJETS          ---------->
      <section>

        <section>
          <h2>2.4 Instancier des objets</h2>
          <p>Instancier : cr√©er un objet √† partir d'une classe</p>
          <p>Chaque objet dispose de son propre jeu d'attributs</p>
          <p>La syntaxe est la m√™me que pour d√©clarer des variables</p>

          <div class="container">
            <div class="col-left">
              <highlight>
                <p>Instanciation automatique</p>
              </highlight>
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">

                int main()
                {
                  // Allocated on the stack
                  <b>Point p1;</b>
                  ...
                  p1.print();
                  ...
                }
              </code></pre>
            </div>
            <div class="col-right">
              <highlight>
                <p>Instanciation dynamique</p>
              </highlight>
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">

                int main()
                {
                  // Allocated on the heap
                  <b>auto *p = new Point;</b> 
                  ...
                  p->print();
                  ...
                  delete p;
                  p = nullptr;
                }
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <h2>2.4 Remarques</h2>
          <p>Un type est utilis√© pour <highlight>d√©clarer</highlight> des variables</p>
          <p>Une classe est utilis√©e pour <highlight>instancier</highlight> des objets</p>
          <br>
          <p>Les attributs et les m√©thodes sont relatifs √† un objet : il est n√©cessaire de commencer par instancier un
            objet √† partir d'une classe avant de pouvoir acc√©der √† ses membres.
            C'est pour cette raison que les membres d'une classe sont parfois appel√©s attributs d'instance ou m√©thodes
            d'instance.</p>
          <br>
        </section>

      </section>

      <!----------          LES CONSTRUCTEURS          ---------->
      <section>

        <section>
          <h2>2.5 Principe du constructeur</h2>
          <p><b>Probl√®me</b></p>
          <p>Entre le moment o√π un objet est instanci√© et son initialisation, l'√©tat interne est <highlight>ind√©termin√©
            </highlight>
          </p>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            
            Point p; // ‚ö†Ô∏è p state is unknown

            p.print(); // ‚ö†Ô∏è (?, ?)

            p.init(3,5);  // Initialisation

            p.print(); // ‚úÖ (3,5)
          </code></pre>
          <br>
          <p>
            <highlight>But du constructeur</highlight>
          </p>
          <p>Initialiser un objet lors de son instanciation</p>
        </section>

        <section>
          <h2>2.5 Principe du constructeur</h2>
          <highlight>
            <p>Instanciation PUIS initialisation</p>
          </highlight>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            Point p;
            p.init(3,5);
          </code></pre>
          <br>
          <highlight>
            <p>Instanciation ET initialisation</p>
          </highlight>
          <p>On peut initialiser l'√©tat interne d'un objet lors de son instanciation gr√¢ce √† un constructeur (m√©thode
            sp√©ciale)</p>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            Point p(3,5);
          </code></pre>

          <p><b>Quand on instancie un objet :</b></p>
          <p>1) La m√©moire n√©cessaire est allou√©e</p>
          <p>2) Le constructeur de la classe est automatiquement appel√© pour initialiser les attributs</p>
        </section>

        <section>
          <h2>2.5 D√©finition d'un constructeur</h2>
          <p>Un constructeur est une m√©thode avec les caract√©ristiques suivantes:</p>
          <p>Son nom est celui de la classe</p>
          <p>Il ne contient pas d'instruction <inline-code>return</inline-code></p>
          <p>Il ne poss√®de pas de type de retour (m√™me pas <inline-code>void</inline-code>)</p>

          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            class Point
            {
              public:
                Point()
                {
                  x = 0;
                  y = 0;
                }

                private:
                  int x, y;
            };
          </code></pre>
        </section>

        <section>
          <h2>2.5 D√©finition d'un constructeur</h2>
          <p>1) ‚úÖ Quand c'est possible, on initialise directement les attributs de l'objet</p>
          <p>2) Ce constructeur devient alors le m√™me que le constructeur par d√©faut</p>

          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            class Point
            {
              public:
                Point()=default; // üìå Optional, but clearer

                private:
                  int x{0}, y{0};
            };
          </code></pre>
        </section>

        <section>
          <h2>2.5 Les diff√©rents constructeurs</h2>
          <p>Un constructeur peut avoir des param√®tres et peut √™tre <highlight>surcharg√©</highlight>. Il peut √™tre
            appel√© le constructeur :</p>
          <p>
            <highlight>Par d√©faut</highlight>
          </p>
          <p><inline-code>Point()</inline-code> - Pas de param√®tre</p>
          <p>
            <highlight>¬´Standard¬ª</highlight>
          </p>
          <p><inline-code>Point(T value1, T value2,...)</inline-code> - Plusieurs param√®tres</p>
          <p>
            <highlight>Par recopie</highlight>
          </p>
          <p><inline-code>Point(const Point &point)</inline-code> - Un param√®tre qui est une r√©f√©rence sur un objet de
            la classe</p>
          <p>
            <highlight>De conversion</highlight>
          </p>
          <p><inline-code>Point(T value)</inline-code> - Un seul param√®tre de type diff√©rent de la classe (ci-dessus)
          </p>
        </section>

        <section>
          <h2>2.5 Constructeurs par d√©faut</h2>
          <p>2 fa√ßons de d√©finir un constructeur par d√©faut (sans param√®tres)</p>

          <div class="container">
            <div class="col-left">
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                
                class Point
                {
                  public:
                    Point()
                    {
                      x = 0;
                      y = 0;
                    }
                    ...
                };
              </code></pre>
            </div>
            <div class="col-right">
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                
                class Point
                {
                 public:
                  Point(int a=0, int b=0);
                  ...
                };                 
                
                Point::Point(int a, int b)
                {
                  x=a; y=b;
                }              
                </code></pre>
            </div>
          </div>
        </section>

        <section>
          <h2>2.5 Constructeurs par d√©faut - Remarques</h2>
          <p>Le constructeur par d√©faut est appel√© chaque fois qu'un objet doit √™tre cr√©√© sans arguments</p>
          <p>Le compilateur fournit un constructeur par d√©faut, si le programmeur n'a √©crit aucun autre constructeur</p>
          <p>Le constructeur par d√©faut propos√© par le compilateur ne fait rien: <inline-code>{ }</inline-code> (pour
            l'instant...)</p>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            
            auto x = Point();
            Point y;

            // ‚ö†Ô∏è Ne jamais mettre de parenth√®ses !
            //    Sinon, c'est une d√©claration de fonction appel√©e z
            // Point z();

            Point t[10]; // 10 appels de Point()
            auto p = new Point;   // √©quiv.√†: p = new Point()
            auto q = new Point[10]; // 10 appels de Point()
          </code></pre>
        </section>

        <section>
          <h2>2.5 Constructeurs standard</h2>
          <p>Un constructeur standard est un constructeur qui prend des param√®tres</p>

          <div class="container">
            <div class="col-left">
              <pre style="width: 800px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                
                class Point
                {
                 public:
                  Point(int a, int b);
                 ...
                };
                
                
                Point::Point(int a, int b)
                {
                  x=a; y=b;
                }
              </code></pre>
            </div>
            <div class="col-right">
              <pre style="width: 900px;"><code
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                
                class Point
                {
                 public:
                 // ‚ö†Ô∏è constructeur par d√©faut !
                  Point(int a=0, int b=0);
                 ...
                };                 
                
                Point::Point(int a, int b)
                {
                  x=a; y=b;
                }
              </code></pre>
            </div>
          </div>
        </section>

        <section>
          <h2>2.5 Constructeurs standard - Remarques</h2>
          <p>Un constructeur standard est appel√© lorsqu'un objet doit √™tre cr√©√© avec des arguments</p>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            
            Point p1(1, 2);
            auto p2 = Point(1, 2);  
            // ‚ö†Ô∏è Use default CTor
            Point p3[10];
            // ‚ö†Ô∏è Use Point(int, int), then use default CTor
            Point p4[4] = {Point(5, 3)};

            auto p5 = new Point(6, 3);
            delete p5;
            
            auto p6 = new Point[10]; 
            for (int i = 0; i < 10; i++)
            {
              p6[i] = Point(2,3);
            }
            delete[] p6;

            std::vector&#60;Point&#62 v(10, Point(2,3));</code></pre>
        </section>

        <section>
          <h2>2.5 Constructeur standard - <span
              style="text-transform: lowercase;"><inline-code>this</inline-code></span></h2>
          <p>Le pointeur <inline-code>this</inline-code> contient l'adresse de l'objet courant</p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">
          
          Point::Point(int x, int y)
          {
            <b>this->x</b> = x;
            <b>this->y</b> = y;
          }
        </code></pre>
          <br>
          <p>1) √âviter le masquage de l'attribut par un param√®tre</p>
          <p>2) Am√©liorer la lisibilit√© du code source: on distingue mieux les m√©thodes/attributs de l'objet courant et les
            fonctions globales</p>
          <p>3) Comparer l'adresse de l'objet courant avec celle d'un autre objet. </p>
        </section>

        <section>
          <h2>2.5 Les constructeurs de conversion</h2>
          <p>Un seul argument obligatoire, d'un autre type simple</p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">
          
          class Point 
          {
           public:
            // Conversion constructor from int
            Point(int a) {x = y = a;}
            ...
          };          
        </code></pre>
          <br>
          <p><b>Exemples</b></p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">
          
          auto p1 = Point(2); 
          Point p2(3); 
          Point p3 = 4; // ‚ö†Ô∏è Implicit conversion          
          p3 = 5; // ‚ö†Ô∏è Implicit conversion
        </code></pre>
        </section>

        <section>
          <h2>üìù 2.5 Les constructeurs de conversion</h2>
          <p>Forcer toutes les conversions √† √™tre explicites : <inline-code>explicit</inline-code></p>

          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">
          
          class Point 
          {
           public:
            // Conversion constructor from int
            <b>explicit</b> Point(int a) {x = y = a;}
            ...
          };          
        </code></pre>
          <br>
          <p><b>Exemples</b></p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">
          
          auto p1 = Point(2); // ‚úÖ Explicit conversion
          Point p2(3); // ‚úÖ Explicit conversion 
          Point p3 = 4; // ‚õî Implicit conversion          
          p3 = 5; // ‚õî Implicit conversion
        </code></pre>
        </section>

        <section>
          <h2>2.5 Constructeurs par copie</h2>
          <p>Un constructeur par copie est un constructeur qui prend en param√®tre une r√©f√©rence constante sur un objet
            de la classe</p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">
          
          class Point 
          {
           public:
            Point(const Point &p) {x = p.x; y = p.y;}
            ...
          };
        </code></pre>
          <br>
          <p><b>Exemples</b></p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">
          
          Point p1(2,3);
          Point p2(p1); // Copy constructor
          auto p3 = p1; // Copy constructor
        </code></pre>
        </section>

        <section>
          <h2>2.5 Constructeurs par copie</h2>
          <p><b>Ce constructeur est souvent appel√© implicitement</b></p>
          <p>1) √Ä l'initialisation d'un objet, avec l'op√©rateur =</p>
          <p><inline-code>Point p2 = anotherPoint;</inline-code></p>
          <p>2) Lorsqu'on passe un objet en param√®tre par valeur √† une fonction</p>
          <p><inline-code>Add(anotherPoint)</inline-code></p>
          <p>3) <highlight>Parfois</highlight> lorsqu'on retourne un objet par valeur (voir copy elision)</p>
          <p><inline-code>return anotherPoint;</inline-code></p>
          <br>
          <br>
          <p><a href="https://en.cppreference.com/w/cpp/language/copy_elision">üìö Copy elision (cppreference)</a></p>
        </section>

        <section>
          <h2>2.5 Constructeurs par copie</h2>
          <p>Le compilateur propose automatiquement un constructeur par copie trivial (bit √† bit). On parle de
            <highlight>"copie en surface"</highlight>.
          </p>
          <p>‚ö†Ô∏è La copie en surface ne fonctionne pas si l'objet contient des pointeurs ou des r√©f√©rences.</p>
          <p>Il est souvent n√©cessaire de red√©finir un constructeur par copie pour r√©aliser une <highlight>"copie en
              profondeur"</highlight>.</p>
        </section>

        <section>
          <h2>2.5 Constructeurs par copie</h2>
          <p><b>Probl√®me</b> : 1 ou plusieurs des attributs sont des pointeurs (ou similaires)</p>

          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.4em;"
          data-line-numbers="">

          class Point
          {
          public:
            ...
            Point(const Point& point) = default;
            // üìå Equivalent to:
            // Point(const Point &point)
            // {
            // 	 this->x = point.x;
            // 	 this->y = point.y;
            // 	 this->name = point.name;
            // }         
            ...                    
            void setName(const char *name)
            {
              strcpy(this->name, name);
            }
          
          private:
            ...          
            <b>char *name = nullptr;</b>
          };
        </code></pre>
        </section>

        <section>
          <h2>2.5 Constructeurs par copie</h2>
          <p><b>Probl√®me</b> : 1 ou plusieurs des attributs sont des pointeurs (ou similaires)</p>

          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">

          int main()
          {
            auto p1 = Point(1, 2, "P1");

            // ‚ö†Ô∏è Shallow copy
            auto p2 = p1;

            // ‚ö†Ô∏è p1 is modified too
            p2.setName("P2");
            
            return 0;
          }          
        </code></pre>
        </section>

        <section>
          <h2>2.5 Constructeurs par copie</h2>
          <p><b>Solution</b> : copie en profondeur</p>

          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.4em;"
          data-line-numbers="12-17">

          class Point
          {
          public:
            ...
            Point(int x, int y, const char *name = "")
            {
              this->x = x;
              this->y = y;
              this->name = new char[strlen(name) + 1];
              strcpy(this->name, name);
            }
            // ‚úÖ Deep copy: allocate new memory, copy content
            <b>Point(const Point &other) : x(other.x), y(other.y)</b>
            <b>{</b>
            <b>  this->name = new char[strlen(other.name) + 1];</b>
            <b>  strcpy(this->name, other.name);</b>
            <b>}</b>

          private:
            ...
            char *name = nullptr;
          };
        </code></pre>
        </section>

        <section>
          <h2>2.5 Appels de constructeurs - Exemples</h2>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">

          auto a = Point(1, 1);
          Point b(2, 2);
          Point c = 3; // ‚õî Implicit conversion
          auto d = new Point(4, 4);
          Point e;
          Point f[4];</code></pre>
          <br>
          <p>Initialisation d'objets temporaires, anonymes</p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">

          std::println("Distance: {}", distance(Point(10,0), Point(3, 4)));</code></pre>
        </section>

        <section>
          <h2>2.5 Appels de constructeurs - Exemples</h2>
          <p>2 interpr√©tations diff√©rentes pour le <inline-code>=</inline-code> :</p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">

          // A)
          auto p = Point(1, 2);

          // B)
          Point p;
          p = Point(1, 2);
        </code></pre>
          <br>
          <p><b>A) 1 appel au constructeur standard</b></p>
          <p>Cette expression cr√©e l'objet p et l'initialise en rangeant dans p.x et p.y les valeurs 1 et 2</p>
        </section>

        <section>
          <h2>2.5 Appels de constructeurs - Exemples</h2>
          <p>2 interpr√©tations diff√©rentes pour le <inline-code>=</inline-code> :</p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">

          // A)
          auto p = Point(1, 2);

          // B)
          Point p;
          p = Point(1, 2);
        </code></pre>
          <br>
          <p><b>B) 2 appels de constructeurs + 1 affectation</b></p>
          <p>- cr√©e un objet p (constructeur par d√©faut)</p>
          <p>- cr√©e un point anonyme de coordonn√©es (1,2)</p>
          <p>- affecte les valeurs des attributs du point anonyme aux attributs de p</p>
          <p>‚ö†Ô∏è Risque si l'op√©rateur <inline-code>=</inline-code> n'est pas surcharg√© pour une copie en profondeur !
          </p>
        </section>

        <section>
          <h2>2.5 Liste d'initialisation</h2>

          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.8em;"
          data-line-numbers="">

          class Point
          {
          public:
            Point(int a, int b) <b>: x(a), y(b)</b> {}
            ...
          };
        </code></pre>
          <p>Une liste d'initialisation est indispensable pour :</p>
          <p>1) initialiser un <highlight>membre constant</highlight>
          </p>
          <p>2) initialiser un <highlight>membre de type r√©f√©rence</highlight>
          </p>
          <p>3) initialiser un <highlight>membre d'un type sans constructeur par d√©faut</highlight>
          </p>
          <br>
          <p>Valable pour tous les constructeurs</p>
          <p>‚úÖ √Ä utiliser autant que possible</p>
        </section>

        <section>
          <h2>2.5 Remarques / Rappels</h2>
          <p>‚ö†Ô∏è Le constructeur par d√©faut fourni par le compilateur <highlight>n'est plus disponible</highlight> si le
            programmeur a d√©fini un constructeur</p>
          <p>Si un constructeur a des valeurs par d√©faut pour ses param√®tres, celles-ci doivent figurer dans la
            d√©claration de la classe (fichier d'interface : <inline-code>classe.h</inline-code>)</p>
          <p>‚ö†Ô∏è Il faut red√©finir le constructeur par copie quand une copie en profondeur est n√©cessaire</p>
          <p>La d√©claration d'un tableau d'objets g√©n√®re autant d'appels au constructeur par d√©faut que d'√©l√©ments dans
            le tableau</p>
        </section>

      </section>

      <!----------          DESTRUCTEUR          ---------->
      <section>

        <section>
          <h2>2.6 Le destructeur</h2>
          <p>
            <highlight>Appel implicite</highlight> √† la destruction d'un objet (auto et dynamique)
          </p>
          <p>
            <highlight>Syntaxe :</highlight> comme pour le constructeur par d√©faut, mais avec
            <inline-code>~</inline-code> devant :
          </p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 2em;"
          data-line-numbers="">

          class Point
          {
          public:
            ...
            ~Point() {...}
            ...
          };
        </code></pre>
          <br>
          <p>1 seul destructeur</p>
          <p>Destructeur par d√©faut g√©n√©r√© par le compilateur (trivial)</p>
          <p>Permet au programmeur de d√©truire proprement un objet (lib√©rer la m√©moire, fermer les flux, stopper les
            threads, etc.)</p>
        </section>

        <section>
          <h2>2.6 Le destructeur</h2>
          <div class="container">
            <div class="col-left">
              <pre style="width: 800px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 2em;"
              data-line-numbers="">

              class PointN 
              {
                public:
                  ~PointN();
              };
              
              PointN::~PointN()
              {
                delete [] nom;
              }
            </code></pre>
            </div>
            <div class="col-right">
              <pre style="width: 800px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 2em;"
              data-line-numbers="">

              int main()
              {
                auto *p = new PointN;
                ...
                delete p;
                ...
                auto *q = new PointN[10];
                ...
                delete [] q;
              }
            </code></pre>
            </div>
          </div>
          <p>Le destructeur est appel√© automatiquement lors de la destruction d'un objet <highlight>puis</highlight> la
            m√©moire r√©serv√©e pour l'objet est lib√©r√©e (d√©sallou√©e)</p>
          <br>
          <p><a href="https://en.cppreference.com/w/cpp/language/destructor">üìö Destructors (cppreference)</a></p>
        </section>
      </section>

      <!----------          LES MEMBRES CONSTANTS          ---------->
      <section>

        <section>
          <h2>2.7 Membres constants</h2>
          <h3>Attributs constants</h3>
          <p>Un attribut d'une classe peut √™tre qualifi√© <highlight>const</highlight>
          </p>
          <p>Initialis√© lors de la construction d'un objet</p>
          <p>Ne peut plus √™tre modifi√© ensuite</p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.8em;"
          data-line-numbers="">
          class Segment
          {
            public:
              Segment(int x,int y, int num);
              ...
            private:
              const int ID{0}; // 1) ‚úÖ OK
          };
          
          Segment::Segment(..., int num){..., ID = num;} // ‚õî Error
          ...          
          Segment::Segment(..., int num) : ID(num){...} // ou 2) ‚úÖ OK
        </code></pre>
        </section>

        <section>
          <h2>2.7 Membres constants</h2>
          <h3>M√©thodes constantes</h3>
          <p>Le mot-cl√© <inline-code>const</inline-code> en fin d'en-t√™te d'une m√©thode indique qu'elle ne change pas
            l'√©tat de l'objet</p>
          <p>C'est une m√©thode de <highlight>consultation de l'objet</highlight>
          </p>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.8em;"
          data-line-numbers="">
          
          class Point
          {
            // Can modify the object
            void setXY(float newX, float newY);

            // Cannot modify the object
            float getX( ) const;
          };
        </code></pre>
        </section>

        <section>
          <h2>2.7 Membres constants</h2>
          <h3>M√©thodes constantes avec objet constant</h3>
          <pre style="width: 1600px;"><code
          class="c++"
          data-trim
          data-noescape
          style="font-size: 1.8em;"
          data-line-numbers="">
          const Point pt = ...;

          auto x = pt.getX();
        </code></pre>

          <p><inline-code>pt</inline-code> est constant donc il ne doit pas √™tre modifi√© par
            <inline-code>getX()</inline-code>
          </p>
          <p>‚áí la qualification <inline-code>const</inline-code> de <inline-code>getX()</inline-code> est
            indispensable</p>
          <br>
          <p>
            <success>‚úÖ Bonne pratique :</success> qualifier <inline-code>const</inline-code> toute m√©thode qui peut
            l'√™tre : cela √©largit son champ d'application
          </p>
        </section>

        <section>
          <h2>2.7 Membres constants</h2>
          <h3>M√©thodes constantes : surcharge</h3>
          <p>Le mot-clef <inline-code>const</inline-code> change la signature d'une m√©thode</p>
          <p>‚áí On peut surcharger une m√©thode non-constante par une m√©thode constante</p>
          <p>La fonction non constante sera appel√©e par les objets variables, la fonction
            <inline-code>const</inline-code> sur les objets constants
          </p>
        </section>

        <section>
          <h2>üå∂Ô∏è 2.7 Membres constants</h2>
          <h3>M√©thodes constantes : surcharge</h3>
          <pre style="width: 1600px;"><code
        class="c++"
        data-trim
        data-noescape
        style="font-size: 1.8em;"
        data-line-numbers="">
        
        class Point
        {
          int x,y;
          
          public:
            int X() const {return x;}
            int &X() {return x;}
        };
        </code></pre>

          <div class="container">
            <div class="col-left">
              <pre style="width: 800px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.4em;"
              data-line-numbers="">

              const Point pC(2, 3);
              int r;
              ...
              r = pC.X(); // ‚úÖ OK
              pC.X() = 15; // ‚õî Error: rvalue
            </code></pre>
            </div>
            <div class="col-right">
              <pre style="width: 800px;"><code
              class="c++"
              data-trim
              data-noescape
              style="font-size: 1.4em;"
              data-line-numbers="">

              Point p(4,5);
              int r;
              ...
              r = p.X(); // ‚úÖ OK
              p.X() = 15; // ‚úÖ OK: lvalue
            </code></pre>
            </div>
          </div>
        </section>

        <section>
          <h2>üå∂Ô∏è 2.7 Membres constants</h2>
          <h3>M√©thodes constantes : surcharge</h3>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            
            class Point
            {
              int x,y;
              
              public:
              int &X() const {return x;} // ‚õî Error
            };
          </code></pre>
          <br>
          <p>Comme <inline-code>X()</inline-code> retourne une r√©f√©rence (=> possibilit√© d'√™tre une lvalue), le
            compilateur ne peut pas
            garantir que la m√©thode soit constante</p>
        </section>
      </section>

      <!----------          POINTEUR THIS, LES MEMBRES STATIQUES ET FRIEND          ---------->
      <section>

        <section>
          <h2>2.8 Pointeur <span style="text-transform: lowercase;"><inline-code>this</inline-code></span></h2>
          <p>Le pointeur <inline-code>this</inline-code> contient l'adresse de l'objet courant</p>
          <br>
          <p><b>üìå Les m√©thodes sont toujours appel√©es depuis un objet</b></p>
          <p>‚áí L'adresse de l'objet est implicitement pass√©e √† la m√©thode appel√©e</p>
          <br>
          <p><inline-code>this</inline-code> est donc le pointeur sur l'objet qui a servi √† appeler la m√©thode</p>
          <p>‚ö†Ô∏è <inline-code>this</inline-code> est un pointeur constant</p>



          <br>
          <p>Le d√©r√©f√©rencement de <inline-code>this</inline-code> donne l'objet courant !</p>
          <p><inline-code>return *this;</inline-code> retourne l'objet lui-m√™me</p>
          <p><inline-code>Point temp(*this);</inline-code> cr√©e une copie de l'objet courant (constructeur par copie)
          </p>
        </section>

        <section>
          <h2>2.8 Pointeur <span style="text-transform: lowercase;"><inline-code>this</inline-code></span></h2>
          <p>1) √âviter le masquage de l'attribut par un param√®tre :</p>
          <pre style="width: 1600px;"><code
            class="c++"
            data-trim
            data-noescape
            style="font-size: 2em;"
            data-line-numbers="">
            
            Point::Point(int x, int y)
            {
              this->x = x;
              this->y = y;
            }
          </code></pre>
          <br>
          <p>2) Am√©liorer la lisibilit√© du code source : on distingue mieux les membres de l'objet courant des
            param√®tres</p>
          <br>
          <p>3) Comparer l'adresse de l'objet courant avec celle d'un autre objet</p>
        </section>

        <section>
          <h2>2.8 Membres statiques</h2>
          <h3>2 cat√©gories de membres (attributs et m√©thodes)</h3>
          <p><b>A) Membres d'instance (cas connu)</b></p>
          <p>- Chaque objet d'une classe a ses propres attributs</p>
          <p>- Les m√©thodes sont appel√©es √† partir des objets d'une classe</p>
          <br>
          <p><b>B) Membres de classe</b></p>
          <p>- Un attribut de classe est unique pour tous les objets d'une classe</p>
          <p>- Une m√©thode de classe peut √™tre appel√©e √† partir de la classe</p>
        </section>

        <section>
          <h2>2.8 Membres statiques</h2>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            
            class Point
            {
              public:
                ...
                <b>static int GetNbPoints() {return nbPoints;}</b>

              private:
                int x{0}, y{0}; // Unique to each object
                <b>static int nbPoints; // Shared by all objects</b>              
            };
          </code></pre>
          <p>‚ö†Ô∏è Un attribut de classe (<inline-code>static</inline-code>) doit √™tre initialis√© en dehors de la classe
          </p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            
            int Point::nbPoints = 0;

            int main()
            {
              ...
              std::println("Nombre de points: {}", Point::GetNbPoints());
            }
          </code></pre>
        </section>

        <section>
          <h2>2.8 Membres statiques - Remarques</h2>
          <p>‚ö†Ô∏è Une m√©thode statique ne peut acc√©der qu'aux membres statiques</p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            
            class Point
            {
              public:
                ...
                static int GetX() {return x;} // ‚õî Error
            };
          </code></pre>
          <br>
          <p>‚ö†Ô∏è Une m√©thode statique ne dispose pas du pointeur <inline-code>this</inline-code></p>
          <br>
          <p>üìå Les m√©thodes statiques sont utilisables sans instancier un objet</p>
        </section>

        <section>
          <h2>2.8 Classes et fonctions <span style="text-transform: lowercase;"><inline-code>friend</inline-code></span>
          </h2>
          <p>Il est possible de passer outre la protection d'acc√®s aux membres priv√©s d'une classe gr√¢ce au mot-cl√©
            <inline-code>friend</inline-code>
          </p>
          <br>
          <p><b>1) Une fonction amie (<inline-code>friend</inline-code>)</b> d'une classe est une fonction qui, sans
            √™tre membre de cette classe, a le droit d'acc√©der √† tous ses membres, aussi bien publics que priv√©s</p>
          <br>
          <p><b>2) Une classe amie (<inline-code>friend</inline-code>)</b> d'une classe <inline-code>C</inline-code> est
            une classe qui a le droit d'acc√©der √† tous les membres de <inline-code>C</inline-code></p>
        </section>

        <section>
          <h2>2.8 Classes et fonctions <span style="text-transform: lowercase;"><inline-code>friend</inline-code></span>
          </h2>
          <p>1) Une fonction amie doit √™tre d√©clar√©e dans la classe qui accorde le droit d'acc√®s</p>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            
            class Point 
            {
              ...              
              public:
                friend void fctExt(Point &p);
              ...
            };
            void fctExt(Point &p)
            { 
              p.x = 0; // ‚úÖ OK: fctExt is a friend of Point
            }          </code></pre>
          <pre style="width: 1600px;"><code 
            class="c++"
            data-trim
            data-noescape
            style="font-size: 1.8em;"
            data-line-numbers="">
            
            int main()
            {
              Point p;
              p.x = 0; // ‚õî Error: x is private
              fctExt(p); // ‚úÖ OK: fctExt is a friend of Point
            }
          </code></pre>
        </section>

        <section>
          <h2>2.8 Classes et fonctions <span style="text-transform: lowercase;"><inline-code>friend</inline-code></span>
          </h2>
          <p>2) Une classe amie doit √™tre d√©clar√©e dans la classe h√¥te</p>
          <pre style="width: 1600px;"><code 
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.8em;"
                data-line-numbers="">
                
                class Host
                {
                  <b>friend class ZeFriend;</b>
                  int x;                  
                  public:
                    Host(int a):x(a){}
                };
            </code></pre>
          <pre style="width: 1600px;"><code 
                class="c++"
                data-trim
                data-noescape
                style="font-size: 1.8em;"
                data-line-numbers="">
                
                class ZeFriend
                {
                  public: 
                    void displayHost()
                    {
                      Host h(16);
                      // ‚úÖ OK: ZeFriend is a friend of Host
                      std::println("Host x = {}", h.x);
                    }
                };
              </code></pre>
        </section>

      </section>

      <!----------          DIAGRAMMES UML          ---------->
      <section>

        <section>
          <h2>2.9 Diagrammes UML</h2>
          <h3>Voir cours 2243.2 G√©nie Logiciel</h3>
        </section>

      </section>

      <!----------          =delete et =default          ---------->
      <section>

        <section>
          <h2>2.10 =delete et =default</h2>
          <p><inline-code>Point()=default</inline-code> force le compilateur √† g√©n√©rer un constructeur par d√©faut</p>
          <p><inline-code>Point()=delete</inline-code> emp√™che le compilateur de g√©n√©rer un constructeur par d√©faut</p>
          <br>
          <p>üìå Fonctionne aussi pour le constructeur par copie, et le destructeur</p>
          <pre style="width: 1600px;"><code 
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                
                class A
                { 
                  public:
                    A()=default;
                    A(const A&) = delete; // No copy allowed
                    ~A()=default;
                };
              </code></pre>
            </section>

            <section>
              <h2>2.10 Constructeurs d√©l√©gu√©s</h2>
              <p>Un constructeur peut appeler un autre constructeur avec des param√®tres diff√©rents</p>
              <pre style="width: 1600px;"><code 
                class="c++"
                data-trim
                data-noescape
                style="font-size: 2em;"
                data-line-numbers="">
                
                class A
                {
                  public:
                    A()=default;
                    A(char x, int y) {}
                    A(int y) : A('a', y) {}
                };
              </code></pre>
            </section>

      </section>
    </div>
  </div>

  <!----------          CONTENT          ---------->

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,
      width: 1920,
      height: 1080,
      transition: "none",
      center: false,
      slideNumber: 'c/t',

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>